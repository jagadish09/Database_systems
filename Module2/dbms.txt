UNIT      OUTCOME                   								  Required       		 COSC
AL- Algorithms and Complexity
Advanced Automata Theory and Computability                                                        0.0/0.0			7.0/15.0
1.	Determine a language’s                                                                    Assessment          		Familiarity
	 place in the
	 Chomsky hierarchy
	 (regular, context-free,
	 recursively
	 enumerable).
2.	Convert among equivalently                                                                Usage               		Assessment
	 powerful notations
	 for a language,
	 including among
	 DFAs, NFAs,
	 and regular
	 expressions,
	 and between
	 PDAs and CFGs.
3.	Explain the Church-Turing                                                                 Familiarity         		None
	 thesis and
	 its significance.
4.	Explain Rice’s Theorem                                                                    Familiarity         		None
	 and its significance.
5.	Provide examples                                                                          Familiarity         		None
	 of uncomputable
	 functions.
6.	Prove that a problem                                                                      Usage               		None
	 is uncomputable
	 by reducing
	 a classic known
	 uncomputable
	 problem to
	 it.
Advanced Computational Complexity                                                                 0.0/0.0			2.0/2.0
1.	Define the classes                                                                        Familiarity         		Assessment
	 P and NP (Also
	 appears in
	 AL/Basic Automata,
	 Computability,
	 and Complexity).
2.	Define the P-space                                                                        Familiarity         		None
	 class and its
	 relation to
	 the EXP class.
3.	Explain the significance                                                                  Familiarity         		None
	 of NP-completeness
	 (Also appears
	 in AL/Basic
	 Automata, Computability,
	 and Complexity).
4.	Provide examples                                                                          Familiarity         		None
	 of classic
	 NP-complete
	 problems.
5.	Prove that a problem                                                                      Usage               		None
	 is NP-complete
	 by reducing
	 a classic known
	 NP-complete
	 problem to
	 it.
Advanced Data Structures Algorithms and Analysis                                                  0.0/0.0			8.0/5.0
1.	Understand the mapping                                                                    Assessment          		Usage
	 of real-world
	 problems to
	 algorithmic
	 solutions (eg,
	 as graph problems,
	 linear programs,
	 etc).
2.	Select and apply                                                                          Assessment          		None
	 advanced algorithmic
	 techniques
	 (eg, randomization,
	 approximation)
	 to solve real
	 problems.
3.	Select and apply                                                                          Assessment          		Assessment
	 advanced analysis
	 techniques
	 (eg, amortized,
	 probabilistic,
	 etc) to algorithms.
Algorithmic Strategies                                                                            5.0/1.0			0.0/0.0
1.	For each of the                                                                           Familiarity         		None
	 strategies
	 (brute-force,
	 greedy, divide-and-conquer,
	 recursive backtracking,
	 and dynamic
	 programming),
	 identify a
	 practical example
	 to which it
	 would apply.
2.	Use a greedy approach                                                                     Assessment          		None
	 to solve an
	 appropriate
	 problem and
	 determine if
	 the greedy
	 rule chosen
	 leads to an
	 optimal solution.
3.	Use a divide-and-conquer                                                                  Usage               		None
	 algorithm to
	 solve an appropriate
	 problem.
4.	Use recursive backtracking                                                                Usage               		None
	 to solve a
	 problem such
	 as navigating
	 a maze.
5.	Use dynamic programming                                                                   Usage               		None
	 to solve an
	 appropriate
	 problem.
6.	Determine an appropriate                                                                  Assessment          		None
	 algorithmic
	 approach to
	 a problem.
7.	Describe various                                                                          Familiarity         		None
	 heuristic problem-solving
	 methods.
8.	Use a heuristic                                                                           Usage               		None
	 approach to
	 solve an appropriate
	 problem.
9.	Describe the trade-offs                                                                   Assessment          		None
	 between brute
	 force and heuristic
	 strategies.
10.	Describe how a branch-and-bound                                                           Familiarity         		None
	 approach may
	 be used to
	 improve the
	 performance
	 of a heuristic
	 method.
Basic Analysis                                                                                    2.0/2.0			2.0/2.0
1.	Explain what is                                                                           Familiarity         		Familiarity
	 meant by best,
	 expected, and
	 worst case
	 behavior of
	 an algorithm.
2.	In the context of                                                                         Assessment          		Familiarity
	 specific algorithms,
	 identify the
	 characteristics
	 of data and/or
	 other conditions
	 or assumptions
	 that lead to
	 different behaviors.
3.	Determine informally                                                                      Usage               		None
	 the time and
	 space complexity
	 of simple algorithms.
4.	State the formal                                                                          Familiarity         		None
	 definition
	 of big O.
5.	List and contrast                                                                         Familiarity         		None
	 standard complexity
	 classes.
6.	Perform empirical                                                                         Assessment          		None
	 studies to
	 validate hypotheses
	 about runtime
	 stemming from
	 mathematical
	 analysis  Run
	 algorithms
	 on input of
	 various sizes
	 and compare
	 performance.
7.	Give examples that                                                                        Familiarity         		None
	 illustrate
	 time-space
	 trade-offs
	 of algorithms.
8.	Use big O notation                                                                        Usage               		None
	 formally to
	 give asymptotic
	 upper bounds
	 on time and
	 space complexity
	 of algorithms.
9.	Use big O notation                                                                        Usage               		None
	 formally to
	 give expected
	 case bounds
	 on time complexity
	 of algorithms.
10.	Explain the use                                                                           Familiarity         		None
	 of big omega,
	 big theta,
	 and little
	 o notation
	 to describe
	 the amount
	 of work done
	 by an algorithm.
11.	Use recurrence relations                                                                  Usage               		None
	 to determine
	 the time complexity
	 of recursively
	 defined algorithms.
12.	Solve elementary                                                                          Usage               		None
	 recurrence
	 relations,
	 eg, using some
	 form of a Master
	 Theorem.
Basic Automata Computability and Complexity                                                       3.0/3.0			7.0/11.0
1.	Discuss the concept                                                                       Familiarity         		Usage
	 of finite state
	 machines.
2.	Design a deterministic                                                                    Usage               		None
	 finite state
	 machine to
	 accept a specified
	 language.
3.	Generate a regular                                                                        Usage               		None
	 expression
	 to represent
	 a specified
	 language.
4.	Explain why the                                                                           Familiarity         		None
	 halting problem
	 has no algorithmic
	 solution.
5.	Design a context-free                                                                     Usage               		None
	 grammar to
	 represent a
	 specified language.
6.	Define the classes                                                                        Familiarity         		None
	 P and NP.
7.	Explain the significance                                                                  Familiarity         		None
	 of NP-completeness.
Fundamental Data Structures and Algorithms                                                        9.0/3.0			6.0/3.0
1.	Implement basic                                                                           Usage               		Familiarity
	 numerical algorithms.
2.	Implement simple                                                                          Assessment          		None
	 search algorithms
	 and explain
	 the differences
	 in their time
	 complexities.
3.	Be able to implement                                                                      Usage               		None
	 common quadratic
	 and O(N log
	 N) sorting
	 algorithms.
4.	Describe the implementation                                                               Familiarity         		None
	 of hash tables,
	 including collision
	 avoidance and
	 resolution.
5.	Discuss the runtime                                                                       Familiarity         		None
	 and memory
	 efficiency
	 of principal
	 algorithms
	 for sorting,
	 searching,
	 and hashing.
6.	Discuss factors                                                                           Familiarity         		None
	 other than
	 computational
	 efficiency
	 that influence
	 the choice
	 of algorithms,
	 such as programming
	 time, maintainability,
	 and the use
	 of application-specific
	 patterns in
	 the input data.
7.	Explain how tree                                                                          Familiarity         		None
	 balance affects
	 the efficiency
	 of various
	 binary search
	 tree operations.
8.	Solve problems using                                                                      Usage               		None
	 fundamental
	 graph algorithms,
	 including depth-first
	 and breadth-first
	 search.
9.	Demonstrate the                                                                           Assessment          		None
	 ability to
	 evaluate algorithms,
	 to select from
	 a range of
	 possible options,
	 to provide
	 justification
	 for that selection,
	 and to implement
	 the algorithm
	 in a particular
	 context.
10.	Describe the heap                                                                         Familiarity         		None
	 property and
	 the use of
	 heaps as an
	 implementation
	 of priority
	 queues.
11.	Solve problems using                                                                      Usage               		None
	 graph algorithms,
	 including single-source
	 and all-pairs
	 shortest paths,
	 and at least
	 one minimum
	 spanning tree
	 algorithm.
12.	Trace and/or implement                                                                    Usage               		None
	 a string-matching
	 algorithm.

AR- Architecture and Organization
Assembly level machine organization                                                               0.0/6.0			2.0/2.0
1.	Explain the organization                                                                  Familiarity         		Familiarity
	 of the classical
	 von Neumann
	 machine and
	 its major functional
	 units.
2.	Describe how an                                                                           Familiarity         		None
	 instruction
	 is executed
	 in a classical
	 von Neumann
	 machine, with
	 extensions
	 for threads,
	 multiprocessor
	 synchronization,
	 and SIMD execution.
3.	Describe instruction                                                                      Familiarity         		None
	 level parallelism
	 and hazards,
	 and how they
	 are managed
	 in typical
	 processor pipelines.
4.	Summarize how instructions                                                                Familiarity         		None
	 are represented
	 at both the
	 machine level
	 and in the
	 context of
	 a symbolic
	 assembler.
5.	Demonstrate how                                                                           Familiarity         		None
	 to map between
	 high-level
	 language patterns
	 into assembly/machine
	 language notations.
6.	Explain different                                                                         Familiarity         		None
	 instruction
	 formats, such
	 as addresses
	 per instruction
	 and variable
	 length vs fixed
	 length formats.
7.	Explain how subroutine                                                                    Familiarity         		None
	 calls are handled
	 at the assembly
	 level.
8.	Explain the basic                                                                         Familiarity         		None
	 concepts of
	 interrupts
	 and I/O operations.
9.	Write simple assembly                                                                     Usage               		None
	 language program
	 segments.
10.	Show how fundamental                                                                      Usage               		None
	 high-level
	 programming
	 constructs
	 are implemented
	 at the machine-language
	 level.
Digital logic and digital systems                                                                 0.0/3.0			2.0/5.0
1.	Describe the progression                                                                  Familiarity         		None
	 of computer
	 technology
	 components
	 from vacuum
	 tubes to VLSI,
	 from mainframe
	 computer architectures
	 to the organization
	 of warehouse-scale
	 computers.
2.	Comprehend the trend                                                                      Familiarity         		Assessment
	 of modern computer
	 architectures
	 towards multi-core
	 and that parallelism
	 is inherent
	 in all hardware
	 systems.
3.	Explain the implications                                                                  Familiarity         		None
	 of the power
	 wall in terms
	 of further
	 processor performance
	 improvements
	 and the drive
	 towards harnessing
	 parallelism.
4.	Articulate that                                                                           Familiarity         		None
	 there are many
	 equivalent
	 representations
	 of computer
	 functionality,
	 including logical
	 expressions
	 and gates,
	 and be able
	 to use mathematical
	 expressions
	 to describe
	 the functions
	 of simple combinational
	 and sequential
	 circuits.
5.	Design the basic                                                                          Usage               		None
	 building blocks
	 of a computer:
	 arithmetic-logic
	 unit (gate-level),
	 registers (gate-level),
	 central processing
	 unit (register
	 transfer-level),
	 memory (register
	 transfer-level).
6.	Use CAD tools for                                                                         Usage               		None
	 capture, synthesis,
	 and simulation
	 to evaluate
	 simple building
	 blocks (eg,
	 arithmetic-logic
	 unit, registers,
	 movement between
	 registers)
	 of a simple
	 computer design.
7.	Evaluate the functional                                                                   Assessment          		None
	 and timing
	 diagram behavior
	 of a simple
	 processor implemented
	 at the logic
	 circuit level.
Functional organization                                                                           0.0/0.0			0.0/0.0
1.	Compare alternative                                                                       Familiarity         		None
	 implementation
	 of datapaths.
2.	Discuss the concept                                                                       Familiarity         		None
	 of control
	 points and
	 the generation
	 of control
	 signals using
	 hardwired or
	 microprogrammed
	 implementations.
3.	Explain basic instruction                                                                 Familiarity         		None
	 level parallelism
	 using pipelining
	 and the major
	 hazards that
	 may occur.
4.	Design and implement                                                                      Usage               		None
	 a complete
	 processor,
	 including datapath
	 and control.
5.	Determine, for a                                                                          Assessment          		None
	 given processor
	 and memory
	 system implementation,
	 the average
	 cycles per
	 instruction.
Interfacing and communication                                                                     0.0/1.0			0.0/0.0
1.	Explain how interrupts                                                                    Familiarity         		None
	 are used to
	 implement I/O
	 control and
	 data transfers.
2.	Identify various                                                                          Familiarity         		None
	 types of buses
	 in a computer
	 system.
3.	Describe data access                                                                      Familiarity         		None
	 from a magnetic
	 disk drive.
4.	Compare common network                                                                    Familiarity         		None
	 organizations,
	 such as ethernet/bus,
	 ring, switched
	 vs routed.
5.	Identify the cross-layer                                                                  Familiarity         		None
	 interfaces
	 needed for
	 multimedia
	 access and
	 presentation,
	 from image
	 fetch from
	 remote storage,
	 through transport
	 over a communications
	 network, to
	 staging into
	 local memory,
	 and final presentation
	 to a graphical
	 display.
6.	Describe the advantages                                                                   Familiarity         		None
	 and limitations
	 of RAID architectures.
Machine level representation of data                                                              0.0/3.0			0.0/0.0
1.	Explain why everything                                                                    Familiarity         		None
	 is data, including
	 instructions,
	 in computers.
2.	Explain the reasons                                                                       Familiarity         		None
	 for using alternative
	 formats to
	 represent numerical
	 data.
3.	Describe how negative                                                                     Familiarity         		None
	 integers are
	 stored in sign-magnitude
	 and twos-complement
	 representations.
4.	Explain how fixed-length                                                                  Familiarity         		None
	 number representations
	 affect accuracy
	 and precision.
5.	Describe the internal                                                                     Familiarity         		None
	 representation
	 of non-numeric
	 data, such
	 as characters,
	 strings, records,
	 and arrays.
6.	Convert numerical                                                                         Usage               		None
	 data from one
	 format to another.
7.	Write simple programs                                                                     Usage               		None
	 at the assembly/machine
	 level for string
	 processing
	 and manipulation.
Memory system organization and architecture                                                       0.0/3.0			1.0/7.0
1.	Identify the main                                                                         Familiarity         		Familiarity
	 types of memory
	 technology
	 (eg, SRAM,
	 DRAM, Flash,
	 magnetic disk)
	 and their relative
	 cost and performance.
2.	Explain the effect                                                                        Familiarity         		None
	 of memory latency
	 on running
	 time.
3.	Describe how the                                                                          Familiarity         		None
	 use of memory
	 hierarchy (cache,
	 virtual memory)
	 is used to
	 reduce the
	 effective memory
	 latency.
4.	Describe the principles                                                                   Familiarity         		None
	 of memory management.
5.	Explain the workings                                                                      Familiarity         		None
	 of a system
	 with virtual
	 memory management.
6.	Compute Average                                                                           Usage               		None
	 Memory Access
	 Time under
	 a variety of
	 cache and memory
	 configurations
	 and mixes of
	 instruction
	 and data references.
Multiprocessing and alternative architectures                                                     0.0/0.0			0.0/0.0
1.	Discuss the concept                                                                       Familiarity         		None
	 of parallel
	 processing
	 beyond the
	 classical von
	 Neumann model.
2.	Describe alternative                                                                      Familiarity         		None
	 parallel architectures
	 such as SIMD
	 and MIMD.
3.	Explain the concept                                                                       Familiarity         		None
	 of interconnection
	 networks and
	 characterize
	 different approaches.
4.	Discuss the special                                                                       Familiarity         		None
	 concerns that
	 multiprocessing
	 systems present
	 with respect
	 to memory management
	 and describe
	 how these are
	 addressed.
5.	Describe the differences                                                                  Familiarity         		None
	 between memory
	 backplane,
	 processor memory
	 interconnect,
	 and remote
	 memory via
	 networks, their
	 implications
	 for access
	 latency and
	 impact on program
	 performance.
Performance enhancements                                                                          0.0/0.0			4.0/4.0
1.	Describe superscalar                                                                      Familiarity         		Assessment
	 architectures
	 and their advantages.
2.	Explain the concept                                                                       Familiarity         		Usage
	 of branch prediction
	 and its utility.
3.	Characterize the                                                                          Familiarity         		None
	 costs and benefits
	 of prefetching.
4.	Explain speculative                                                                       Familiarity         		None
	 execution and
	 identify the
	 conditions
	 that justify
	 it.
5.	Discuss the performance                                                                   Familiarity         		None
	 advantages
	 that multithreading
	 offered in
	 an architecture
	 along with
	 the factors
	 that make it
	 difficult to
	 derive maximum
	 benefits from
	 this approach.
6.	Describe the relevance                                                                    Familiarity         		None
	 of scalability
	 to performance.

CN- Computational Science
Data, Information, and Knowledge                                                                  0.0/0.0			0.0/0.0
1.	Identify all of                                                                           Assessment          		None
	 the data, information,
	 and knowledge
	 elements and
	 related organizations,
	 for a computational
	 science application.
2.	Describe how to                                                                           Familiarity         		None
	 represent data
	 and information
	 for processing.
3.	Describe typical                                                                          Familiarity         		None
	 user requirements
	 regarding that
	 data, information,
	 and knowledge.
4.	Select a suitable                                                                         Assessment          		None
	 system or software
	 implementation
	 to manage data,
	 information,
	 and knowledge.
5.	List and describe                                                                         Familiarity         		None
	 the reports,
	 transactions,
	 and other processing
	 needed for
	 a computational
	 science application.
6.	Compare and contrast                                                                      Assessment          		None
	 database management,
	 information
	 retrieval,
	 and digital
	 library systems
	 with regard
	 to handling
	 typical computational
	 science applications.
7.	Design a digital                                                                          Usage               		None
	 library for
	 some computational
	 science users
	 / societies,
	 with appropriate
	 content and
	 services.
Interactive Visualization                                                                         0.0/0.0			0.0/0.0
1.	Compare common computer                                                                   Assessment          		None
	 interface mechanisms
	 with respect
	 to ease-of-use,
	 learnability,
	 and cost.
2.	Use standard APIs                                                                         Usage               		None
	 and tools to
	 create visual
	 displays of
	 data, including
	 graphs, charts,
	 tables, and
	 histograms.
3.	Describe several                                                                          Familiarity         		None
	 approaches
	 to using a
	 computer as
	 a means for
	 interacting
	 with and processing
	 data.
4.	Extract useful information                                                                Assessment          		None
	 from a dataset.
5.	Analyze and select                                                                        Assessment          		None
	 visualization
	 techniques
	 for specific
	 problems.
6.	Describe issues                                                                           Familiarity         		None
	 related to
	 scaling data
	 analysis from
	 small to large
	 data sets.
Introduction to Modeling and Simulation                                                           1.0/0.0			2.0/8.0
1.	Explain the concept                                                                       Familiarity         		Assessment
	 of modeling
	 and the use
	 of abstraction
	 that allows
	 the use of
	 a machine to
	 solve a problem.
2.	Describe the relationship                                                                 Familiarity         		Familiarity
	 between modeling
	 and simulation,
	 ie, thinking
	 of simulation
	 as dynamic
	 modeling.
3.	Create a simple,                                                                          Usage               		None
	 formal mathematical
	 model of a
	 real-world
	 situation and
	 use that model
	 in a simulation.
4.	Differentiate among                                                                       Familiarity         		None
	 the different
	 types of simulations,
	 including physical
	 simulations,
	 human-guided
	 simulations,
	 and virtual
	 reality.
5.	Describe several                                                                          Familiarity         		None
	 approaches
	 to validating
	 models.
6.	Create a simple                                                                           Usage               		None
	 display of
	 the results
	 of a simulation.
Modeling and Simulation                                                                           0.0/0.0			0.0/0.0
1.	Explain and give                                                                          Familiarity         		None
	 examples of
	 the benefits
	 of simulation
	 and modeling
	 in a range
	 of important
	 application
	 areas.
2.	Demonstrate the                                                                           Usage               		None
	 ability to
	 apply the techniques
	 of modeling
	 and simulation
	 to a range
	 of problem
	 areas.
3.	Explain the constructs                                                                    Familiarity         		None
	 and concepts
	 of a particular
	 modeling approach.
4.	Explain the difference                                                                    Assessment          		None
	 between validation
	 and verification
	 of a model;
	 demonstrate
	 the difference
	 with specific
	 examples.
5.	Verify and validate                                                                       Assessment          		None
	 the results
	 of a simulation.
6.	Evaluate a simulation,                                                                    Assessment          		None
	 highlighting
	 the benefits
	 and the drawbacks.
7.	Choose an appropriate                                                                     Assessment          		None
	 modeling approach
	 for a given
	 problem or
	 situation.
8.	Compare results                                                                           Assessment          		None
	 from different
	 simulations
	 of the same
	 situation and
	 explain any
	 differences.
9.	Infer the behavior                                                                        Assessment          		None
	 of a system
	 from the results
	 of a simulation
	 of the system.
10.	Extend or adapt                                                                           Assessment          		None
	 an existing
	 model to a
	 new situation.
Numerical Analysis                                                                                0.0/0.0			0.0/0.0
1.	Define error, stability,                                                                  Familiarity         		None
	 machine precision
	 concepts and
	 the inexactness
	 of computational
	 approximations.
2.	Implement Taylor                                                                          Usage               		None
	 series, interpolation,
	 extrapolation,
	 and regression
	 algorithms
	 for approximating
	 functions.
3.	Implement algorithms                                                                      Usage               		None
	 for differentiation
	 and integration.
4.	Implement algorithms                                                                      Usage               		None
	 for solving
	 differential
	 equations.
Processing                                                                                        0.0/0.0			0.0/0.0
1.	Explain the characteristics                                                               Familiarity         		None
	 and defining
	 properties
	 of algorithms
	 and how they
	 relate to machine
	 processing.
2.	Analyze simple problem                                                                    Assessment          		None
	 statements
	 to identify
	 relevant information
	 and select
	 appropriate
	 processing
	 to solve the
	 problem.
3.	Identify or sketch                                                                        Familiarity         		None
	 a workflow
	 for an existing
	 computational
	 process such
	 as the creation
	 of a graph
	 based on experimental
	 data.
4.	Describe the process                                                                      Familiarity         		None
	 of converting
	 an algorithm
	 to machine-executable
	 code.
5.	Summarize the phases                                                                      Familiarity         		None
	 of software
	 development
	 and compare
	 several common
	 lifecycle models.
6.	Explain how data                                                                          Familiarity         		None
	 is represented
	 in a machine
	 Compare representations
	 of integers
	 to floating
	 point numbers
	 Describe underflow,
	 overflow, round
	 off, and truncation
	 errors in data
	 representations.
7.	Apply standard numerical                                                                  Usage               		None
	 algorithms
	 to solve ODEs
	 and PDEs Use
	 computing systems
	 to solve systems
	 of equations.
8.	Describe the basic                                                                        Familiarity         		None
	 properties
	 of bandwidth,
	 latency, scalability
	 and granularity.
9.	Describe the levels                                                                       Familiarity         		None
	 of parallelism
	 including task,
	 data, and event
	 parallelism.
10.	Compare and contrast                                                                      Assessment          		None
	 parallel programming
	 paradigms recognizing
	 the strengths
	 and weaknesses
	 of each.
11.	Identify the issues                                                                       Familiarity         		None
	 impacting correctness
	 and efficiency
	 of a computation.
12.	Design, code, test                                                                        Usage               		None
	 and debug programs
	 for a parallel
	 computation.

DS- Discrete Structures
Basic Logic                                                                                       9.0/0.0			0.0/0.0
1.	Convert logical                                                                           Usage               		None
	 statements
	 from informal
	 language to
	 propositional
	 and predicate
	 logic expressions.
2.	Apply formal methods                                                                      Usage               		None
	 of symbolic
	 propositional
	 and predicate
	 logic, such
	 as calculating
	 validity of
	 formulae and
	 computing normal
	 forms.
3.	Use the rules of                                                                          Usage               		None
	 inference to
	 construct proofs
	 in propositional
	 and predicate
	 logic.
4.	Describe how symbolic                                                                     Usage               		None
	 logic can be
	 used to model
	 real-life situations
	 or applications,
	 including those
	 arising in
	 computing contexts
	 such as software
	 analysis (eg,
	 program correctness),
	 database queries,
	 and algorithms.
5.	Apply formal logic                                                                        Usage               		None
	 proofs and/or
	 informal, but
	 rigorous, logical
	 reasoning to
	 real problems,
	 such as predicting
	 the behavior
	 of software
	 or solving
	 problems such
	 as puzzles.
6.	Describe the strengths                                                                    Familiarity         		None
	 and limitations
	 of propositional
	 and predicate
	 logic.
Basics of Counting                                                                                5.0/0.0			0.0/0.0
1.	Apply counting arguments,                                                                 Usage               		None
	 including sum
	 and product
	 rules, inclusion-exclusion
	 principle and
	 arithmetic/geometric
	 progressions.
2.	Apply the pigeonhole                                                                      Usage               		None
	 principle in
	 the context
	 of a formal
	 proof.
3.	Compute permutations                                                                      Usage               		None
	 and combinations
	 of a set, and
	 interpret the
	 meaning in
	 the context
	 of the particular
	 application.
4.	Map real-world applications                                                               Usage               		None
	 to appropriate
	 counting formalisms,
	 such as determining
	 the number
	 of ways to
	 arrange people
	 around a table,
	 subject to
	 constraints
	 on the seating
	 arrangement,
	 or the number
	 of ways to
	 determine certain
	 hands in cards
	 (eg, a full
	 house).
5.	Solve a variety                                                                           Usage               		None
	 of basic recurrence
	 relations.
6.	Analyze a problem                                                                         Usage               		None
	 to determine
	 underlying
	 recurrence
	 relations.
7.	Perform computations                                                                      Usage               		None
	 involving modular
	 arithmetic.
Discrete Probability                                                                              6.0/2.0			0.0/0.0
1.	Calculate probabilities                                                                   Usage               		None
	 of events and
	 expectations
	 of random variables
	 for elementary
	 problems such
	 as games of
	 chance.
2.	Differentiate between                                                                     Usage               		None
	 dependent and
	 independent
	 events.
3.	Identify a case                                                                           Usage               		None
	 of the binomial
	 distribution
	 and compute
	 a probability
	 using that
	 distribution.
4.	Apply Bayes theorem                                                                       Usage               		None
	 to determine
	 conditional
	 probabilities
	 in a problem.
5.	Apply the tools                                                                           Usage               		None
	 of probability
	 to solve problems
	 such as the
	 average case
	 analysis of
	 algorithms
	 or analyzing
	 hashing.
6.	Compute the variance                                                                      Usage               		None
	 for a given
	 probability
	 distribution.
7.	Explain how events                                                                        Usage               		None
	 that are independent
	 can be conditionally
	 dependent (and
	 vice-versa)
	  Identify real-world
	 examples of
	 such cases.
Graphs and Trees                                                                                  3.0/1.0			0.0/0.0
1.	Illustrate by example                                                                     Familiarity         		None
	 the basic terminology
	 of graph theory,
	 and some of
	 the properties
	 and special
	 cases of each
	 type of graph/tree.
2.	Demonstrate different                                                                     Usage               		None
	 traversal methods
	 for trees and
	 graphs, including
	 pre, post,
	 and in-order
	 traversal of
	 trees.
3.	Model a variety                                                                           Usage               		None
	 of real-world
	 problems in
	 computer science
	 using appropriate
	 forms of graphs
	 and trees,
	 such as representing
	 a network topology
	 or the organization
	 of a hierarchical
	 file system.
4.	Show how concepts                                                                         Usage               		None
	 from graphs
	 and trees appear
	  in data structures,
	 algorithms,
	 proof techniques
	 (structural
	 induction),
	 and counting.
5.	Explain how to construct                                                                  Usage               		None
	 a spanning
	 tree of a graph.
6.	Determine if two                                                                          Usage               		None
	 graphs are
	 isomorphic.
Proof Techniques                                                                                  10.0/1.0			0.0/0.0
1.	Identify the proof                                                                        Familiarity         		None
	 technique used
	 in a given
	 proof.
2.	Outline the basic                                                                         Usage               		None
	 structure of
	 each proof
	 technique (direct
	 proof, proof
	 by contradiction,
	 and induction)
	 described in
	 this unit.
3.	Apply each of the                                                                         Usage               		None
	 proof techniques
	 (direct proof,
	 proof by contradiction,
	 and induction)
	 correctly in
	 the construction
	 of a sound
	 argument.
4.	Determine which                                                                           Assessment          		None
	 type of proof
	 is best for
	 a given problem.
5.	Explain the parallels                                                                     Assessment          		None
	 between ideas
	 of mathematical
	 and/or structural
	 induction to
	 recursion and
	 recursively
	 defined structures.
6.	Explain the relationship                                                                  Assessment          		None
	 between weak
	 and strong
	 induction and
	 give examples
	 of the appropriate
	 use of each.
7.	State the well-ordering                                                                   Familiarity         		None
	 principle and
	 its relationship
	 to mathematical
	 induction.
Sets, Relations, and Functions                                                                    4.0/0.0			0.0/0.0
1.	Explain with examples                                                                     Familiarity         		None
	 the basic terminology
	 of functions,
	 relations,
	 and sets.
2.	Perform the operations                                                                    Usage               		None
	 associated
	 with sets,
	 functions,
	 and relations.
3.	Relate practical                                                                          Assessment          		None
	 examples to
	 the appropriate
	 set, function,
	 or relation
	 model, and
	 interpret the
	 associated
	 operations
	 and terminology
	 in context.

GV- Graphics and Visualization
Advanced Rendering                                                                                0.0/0.0			0.0/0.0
1.	Demonstrate how                                                                           Assessment          		None
	 an algorithm
	 estimates a
	 solution to
	 the rendering
	 equation.
2.	Prove the properties                                                                      Assessment          		None
	 of a rendering
	 algorithm,
	 eg, complete,
	 consistent,
	 and unbiased.
3.	Analyze the bandwidth                                                                     Assessment          		None
	 and computation
	 demands of
	 a simple algorithm.
4.	Implement a non-trivial                                                                   Usage               		None
	 shading algorithm
	 (eg, toon shading,
	 cascaded shadow
	 maps) under
	 a rasterization
	 API.
5.	Discuss how a particular                                                                  Familiarity         		None
	 artistic technique
	 might be implemented
	 in a renderer.
6.	Explain how to recognize                                                                  Familiarity         		None
	 the graphics
	 techniques
	 used to create
	 a particular
	 image.
7.	Implement any of                                                                          Usage               		None
	 the specified
	 graphics techniques
	 using a primitive
	 graphics system
	 at the individual
	 pixel level.
8.	Implement a ray                                                                           Usage               		None
	 tracer for
	 scenes using
	 a simple (eg,
	 Phong’s) BRDF
	 plus reflection
	 and refraction.
Basic Rendering                                                                                   0.0/0.0			0.0/0.0
1.	Discuss the light                                                                         Familiarity         		None
	 transport problem
	 and its relation
	 to numerical
	 integration
	 ie, light is
	 emitted, scatters
	 around the
	 scene, and
	 is measured
	 by the eye.
2.	Describe the basic                                                                        Familiarity         		None
	 graphics pipeline
	 and how forward
	 and backward
	 rendering factor
	 in this.
3.	Create a program                                                                          Usage               		None
	 to display
	 3D models of
	 simple graphics
	 images.
4.	Derive linear perspective                                                                 Usage               		None
	 from similar
	 triangles by
	 converting
	 points (x,
	 y, z) to points
	 (x/z, y/z,
	 1).
5.	Obtain 2-dimensional                                                                      Usage               		None
	 and 3-dimensional
	 points by applying
	 affine transformations.
6.	Apply 3-dimensional                                                                       Usage               		None
	 coordinate
	 system and
	 the changes
	 required to
	 extend 2D transformation
	 operations
	 to handle transformations
	 in 3D.
7.	Contrast forward                                                                          Assessment          		None
	 and backward
	 rendering.
8.	Explain the concept                                                                       Familiarity         		None
	 and applications
	 of texture
	 mapping, sampling,
	 and anti-aliasing.
9.	Explain the ray                                                                           Familiarity         		None
	 tracing/rasterization
	 duality for
	 the visibility
	 problem.
10.	Implement simple                                                                          Usage               		None
	 procedures
	 that perform
	 transformation
	 and clipping
	 operations
	 on simple 2-dimensional
	 images.
11.	Implement a simple                                                                        Usage               		None
	 real-time renderer
	 using a rasterization
	 API (eg, OpenGL)
	 using vertex
	 buffers and
	 shaders.
12.	Compare and contrast                                                                      Assessment          		None
	 the different
	 rendering techniques.
13.	Compute space requirements                                                                Assessment          		None
	 based on resolution
	 and color coding.
14.	Compute time requirements                                                                 Assessment          		None
	 based on refresh
	 rates, rasterization
	 techniques.
Computer Animation                                                                                0.0/0.0			0.0/0.0
1.	Compute the location                                                                      Usage               		None
	 and orientation
	 of model parts
	 using an forward
	 kinematic approach.
2.	Compute the orientation                                                                   Usage               		None
	 of articulated
	 parts of a
	 model from
	 a location
	 and orientation
	 using an inverse
	 kinematic approach.
3.	Describe the tradeoffs                                                                    Assessment          		None
	 in different
	 representations
	 of rotations.
4.	Implement the spline                                                                      Usage               		None
	 interpolation
	 method for
	 producing in-between
	 positions and
	 orientations.
5.	Implement algorithms                                                                      Usage               		None
	 for physical
	 modeling of
	 particle dynamics
	 using simple
	 Newtonian mechanics,
	 for example
	 Witkin & Kass,
	 snakes and
	 worms, symplectic
	 Euler, Stormer/Verlet,
	 or midpoint
	 Euler methods.
6.	Discuss the basic                                                                         Familiarity         		None
	 ideas behind
	 some methods
	 for fluid dynamics
	 for modeling
	 ballistic trajectories,
	 for example
	 for splashes,
	 dust, fire,
	 or smoke.
7.	Use common animation                                                                      Usage               		None
	 software to
	 construct simple
	 organic forms
	 using metaball
	 and skeleton.
Fundamental Concepts                                                                              2.0/1.0			0.0/0.0
1.	Identify common                                                                           Familiarity         		None
	 uses of digital
	 presentation
	 to humans (eg,
	 computer graphics,
	 sound).
2.	Explain in general                                                                        Familiarity         		None
	 terms how analog
	 signals can
	 be reasonably
	 represented
	 by discrete
	 samples, for
	 example, how
	 images can
	 be represented
	 by pixels.
3.	Explain how the                                                                           Familiarity         		None
	 limits of human
	 perception
	 affect choices
	 about the digital
	 representation
	 of analog signals.
4.	Construct a simple                                                                        Usage               		None
	 user interface
	 using a standard
	 API.
5.	Describe the differences                                                                  Familiarity         		None
	 between lossy
	 and lossless
	 image compression
	 techniques,
	 for example
	 as reflected
	 in common graphics
	 image file
	 formats such
	 as  JPG, PNG,
	 MP3, MP4, and
	 GIF.
6.	Describe color models                                                                     Familiarity         		None
	 and their use
	 in graphics
	 display devices.
7.	Describe the tradeoffs                                                                    Familiarity         		None
	 between storing
	 information
	 vs storing
	 enough information
	 to reproduce
	 the information,
	 as in the difference
	 between vector
	 and raster
	 rendering.
8.	Describe the basic                                                                        Familiarity         		None
	 process of
	 producing continuous
	 motion from
	 a sequence
	 of discrete
	 frames (sometimes
	 called flicker
	 fusion).
9.	Describe how double-buffering                                                             Familiarity         		None
	 can remove
	 flicker from
	 animation.
Geometric Modeling                                                                                0.0/0.0			0.0/0.0
1.	Represent curves                                                                          Usage               		None
	 and surfaces
	 using both
	 implicit and
	 parametric
	 forms.
2.	Create simple polyhedral                                                                  Usage               		None
	 models by surface
	 tessellation.
3.	Generate a mesh                                                                           Usage               		None
	 representation
	 from an implicit
	 surface.
4.	Generate a fractal                                                                        Usage               		None
	 model or terrain
	 using a procedural
	 method.
5.	Generate a mesh                                                                           Usage               		None
	 from data points
	 acquired with
	 a laser scanner.
6.	Construct CSG models                                                                      Usage               		None
	 from simple
	 primitives,
	 such as cubes
	 and quadric
	 surfaces.
7.	Contrast modeling                                                                         Assessment          		None
	 approaches
	 with respect
	 to space and
	 time complexity
	 and quality
	 of image.
Visualization                                                                                     0.0/0.0			0.0/0.0
1.	Describe the basic                                                                        Familiarity         		None
	 algorithms
	 for scalar
	 and vector
	 visualization.
2.	Describe the tradeoffs                                                                    Assessment          		None
	 of visualization
	 algorithms
	 in terms of
	 accuracy and
	 performance.
3.	Propose a suitable                                                                        Assessment          		None
	 visualization
	 design for
	 a particular
	 combination
	 of data characteristics
	 and application
	 tasks.
4.	Analyze the effectiveness                                                                 Assessment          		None
	 of a given
	 visualization
	 for a particular
	 task.
5.	Design a process                                                                          Assessment          		None
	 to evaluate
	 the utility
	 of a visualization
	 algorithm or
	 system.
6.	Recognize a variety                                                                       Familiarity         		None
	 of applications
	 of visualization
	 including representations
	 of scientific,
	 medical, and
	 mathematical
	 data; flow
	 visualization;
	 and spatial
	 analysis.

HCI- Human-Computer Interaction
Collaboration and communication                                                                   0.0/0.0			0.0/0.0
1.	Describe the difference                                                                   Familiarity         		None
	 between synchronous
	 and asynchronous
	 communication.
2.	Compare the HCI                                                                           Assessment          		None
	 issues in individual
	 interaction
	 with group
	 interaction.
3.	Discuss several                                                                           Familiarity         		None
	 issues of social
	 concern raised
	 by collaborative
	 software.
4.	Discuss the HCI                                                                           Familiarity         		None
	 issues in software
	 that embodies
	 human intention.
Design-oriented HCI                                                                               0.0/4.0			0.0/0.0
1.	Explain what is                                                                           Familiarity         		None
	 meant by HCI
	 is a design-oriented
	 discipline.
2.	Detail the processes                                                                      Familiarity         		None
	 of design appropriate
	 to specific
	 design orientations.
3.	Apply a variety                                                                           Usage               		None
	 of design methods
	 to a given
	 problem.
Designing Interaction                                                                             0.0/0.0			0.0/0.0
1.	For an identified                                                                         Assessment          		None
	 user group,
	 undertake and
	 document an
	 analysis of
	 their needs.
2.	Create a simple                                                                           Usage               		None
	 application,
	 together with
	 help and documentation,
	 that supports
	 a graphical
	 user interface.
3.	Conduct a quantitative                                                                    Usage               		None
	 evaluation
	 and discuss/report
	 the results.
4.	Discuss at least                                                                          Familiarity         		None
	 one national
	 or international
	 user interface
	 design standard.
Foundations                                                                                       4.0/0.0			0.0/0.0
1.	Discuss why human-centered                                                                Familiarity         		None
	 software development
	 is important.
2.	Summarize the basic                                                                       Familiarity         		None
	 precepts of
	 psychological
	 and social
	 interaction.
3.	Develop and use                                                                           Usage               		None
	 a conceptual
	 vocabulary
	 for analyzing
	 human interaction
	 with software:
	 affordance,
	 conceptual
	 model, feedback,
	 and so forth.
4.	Define a user-centered                                                                    Usage               		None
	 design process
	 that explicitly
	 takes account
	 of  the fact
	 that the user
	 is not like
	 the developer
	 or their acquaintances.
5.	Create and conduct                                                                        Assessment          		None
	 a simple usability
	 test for an
	 existing software
	 application.
Human factors and security                                                                        0.0/0.0			0.0/0.0
1.	Explain the concepts                                                                      Familiarity         		None
	 of phishing
	 and spear phishing,
	 and how to
	 recognize them.
2.	Describe the issues                                                                       Assessment          		None
	 of trust in
	 interface design
	 with an example
	 of a high and
	 low trust system.
3.	Design a user interface                                                                   Assessment          		None
	 for a security
	 mechanism.
4.	Explain the concept                                                                       Familiarity         		None
	 of identity
	 management
	 and its importance.
5.	Analyze a security                                                                        Usage               		None
	 policy and/or
	 procedures
	 to show where
	 they consider,
	 or fail to
	 consider, human
	 factors.
Mixed, Augmented and Virtual Reality                                                              0.0/0.0			0.0/0.0
1.	Describe the optical                                                                      Familiarity         		None
	 model realized
	 by a computer
	 graphics system
	 to synthesize
	 stereoscopic
	 view.
2.	Describe the principles                                                                   Familiarity         		None
	 of different
	 viewer tracking
	 technologies.
3.	Describe the differences                                                                  Familiarity         		None
	 between geometry-
	 and image-based
	 virtual reality.
4.	Describe the issues                                                                       Familiarity         		None
	 of user action
	 synchronization
	 and data consistency
	 in a networked
	 environment.
5.	Determine the basic                                                                       Usage               		None
	 requirements
	 on interface,
	 hardware, and
	 software configurations
	 of a VR system
	 for a specified
	 application.
6.	Describe several                                                                          Familiarity         		None
	 possible uses
	 for games engines,
	 including their
	 potential and
	 their limitations.
New Interactive Technologies                                                                      0.0/0.0			0.0/0.0
1.	Describe when non-mouse                                                                   Familiarity         		None
	 interfaces
	 are appropriate.
2.	Understand the interaction                                                                Familiarity         		None
	 possibilities
	 beyond mouse-and-pointer
	 interfaces.
3.	Discuss the advantages                                                                    Assessment          		None
	 (and disadvantages)
	 of non-mouse
	 interfaces.
Programming Interactive Systems                                                                   0.0/0.0			0.0/0.0
1.	Explain the importance                                                                    Familiarity         		None
	 of Model-View
	 controller
	 to interface
	 programming.
2.	Create an application                                                                     Usage               		None
	 with a modern
	 graphical user
	 interface.
3.	Identify commonalities                                                                    Familiarity         		None
	 and differences
	 in UIs across
	 different platforms.
4.	Explain and use                                                                           Familiarity         		None
	 GUI programming
	 concepts: event
	 handling, constraint-based
	 layout management,
	 etc.
Statistical methods for HCI                                                                       0.0/0.0			0.0/0.0
1.	Explain basic statistical                                                                 Familiarity         		None
	 concepts and
	 their areas
	 of application.
2.	Extract and articulate                                                                    Usage               		None
	 the statistical
	 arguments used
	 in papers that
	 quantitatively
	 report user
	 studies.
3.	Design a user study                                                                       Usage               		None
	 that will yield
	 quantitative
	 results.
4.	Conduct and report                                                                        Usage               		None
	 on a study
	 that utilizes
	 both qualitative
	 and quantitative
	 evaluation.
User-centered design and testing                                                                  0.0/0.0			0.0/0.0
1.	Explain how user-centred                                                                  Familiarity         		None
	 design complements
	 other software
	 process models.
2.	Use lo-fi (low fidelity)                                                                  Usage               		None
	 prototyping
	 techniques
	 to gather,
	 and report,
	 user responses.
3.	Choose appropriate                                                                        Assessment          		None
	 methods to
	 support the
	 development
	 of a specific
	 UI.
4.	Use a variety of                                                                          Assessment          		None
	 techniques
	 to evaluate
	 a given UI.
5.	Compare the constraints                                                                   Assessment          		None
	 and benefits
	 of different
	 evaluative
	 methods.

IAS- Information Assurance and Security
Cryptography                                                                                      0.0/1.0			0.0/0.0
1.	Describe the purpose                                                                      Familiarity         		None
	 of Cryptography
	 and list ways
	 it is used
	 in data communications.
2.	Define the following                                                                      Familiarity         		None
	 terms: Cipher,
	 Cryptanalysis,
	 Cryptographic
	 Algorithm,
	 and Cryptology
	 and describe
	 the two basic
	 methods (ciphers)
	 for transforming
	 plain text
	 in cipher text.
3.	Discuss the importance                                                                    Familiarity         		None
	 of prime numbers
	 in cryptography
	 and explain
	 their use in
	 cryptographic
	 algorithms.
4.	Explain how Public                                                                        Familiarity         		None
	 Key Infrastructure
	 supports digital
	 signing and
	 encryption
	 and discuss
	 the limitations/vulnerabilities.
5.	Use cryptographic                                                                         Usage               		None
	 primitives
	 and their basic
	 properties.
6.	Illustrate how to                                                                         Usage               		None
	 measure entropy
	 and how to
	 generate cryptographic
	 randomness.
7.	Use public-key primitives                                                                 Usage               		None
	 and their applications.
8.	Explain how key                                                                           Familiarity         		None
	 exchange protocols
	 work and how
	 they fail.
9.	Discuss cryptographic                                                                     Familiarity         		None
	 protocols and
	 their properties.
10.	Describe real-world                                                                       Familiarity         		None
	 applications
	 of cryptographic
	 primitives
	 and protocols.
11.	Summarize precise                                                                         Familiarity         		None
	 security definitions,
	 attacker capabilities
	 and goals.
12.	Apply appropriate                                                                         Usage               		None
	 known cryptographic
	 techniques
	 for a given
	 scenario.
13.	Appreciate the dangers                                                                    Familiarity         		None
	 of inventing
	 one’s own cryptographic
	 methods.
14.	Describe quantum                                                                          Familiarity         		None
	 cryptography
	 and the impact
	 of quantum
	 computing on
	 cryptographic
	 algorithms.
Defensive Programming                                                                             1.0/2.0			0.0/0.0
1.	Explain why input                                                                         Familiarity         		None
	 validation
	 and data sanitization
	 is necessary
	 in the face
	 of adversarial
	 control of
	 the input channel.
2.	Explain why you                                                                           Familiarity         		None
	 might choose
	 to develop
	 a program in
	 a type-safe
	 language like
	 Java, in contrast
	 to an unsafe
	 programming
	 language like
	 C/C++.
3.	Classify common                                                                           Usage               		None
	 input validation
	 errors, and
	 write correct
	 input validation
	 code.
4.	Demonstrate using                                                                         Usage               		None
	 a high-level
	 programming
	 language how
	 to prevent
	 a race condition
	 from occurring
	 and how to
	 handle an exception.
5.	Demonstrate the                                                                           Usage               		None
	 identification
	 and graceful
	 handling of
	 error conditions.
6.	Explain the risks                                                                         Familiarity         		None
	 with misusing
	 interfaces
	 with third-party
	 code and how
	 to correctly
	 use third-party
	 code.
7.	Discuss the need                                                                          Familiarity         		None
	 to update software
	 to fix security
	 vulnerabilities
	 and the lifecycle
	 management
	 of the fix.
8.	List examples of                                                                          Familiarity         		None
	 direct and
	 indirect information
	 flows.
9.	Explain the role                                                                          Familiarity         		None
	 of random numbers
	 in security,
	 beyond just
	 cryptography
	 (eg password
	 generation,
	 randomized
	 algorithms
	 to avoid algorithmic
	 denial of service
	 attacks).
10.	Explain the different                                                                     Familiarity         		None
	 types of mechanisms
	 for detecting
	 and mitigating
	 data sanitization
	 errors.
11.	Demonstrate how                                                                           Usage               		None
	 programs are
	 tested for
	 input handling
	 errors.
12.	Use static and dynamic                                                                    Usage               		None
	 tools to identify
	 programming
	 faults.
13.	Describe how memory                                                                       Familiarity         		None
	 architecture
	 is used to
	 protect runtime
	 attacks.
Digital Forensics                                                                                 0.0/0.0			0.0/0.0
1.	Describe what is                                                                          Familiarity         		None
	 a Digital Investigation
	 is, the sources
	 of digital
	 evidence, and
	 the limitations
	 of forensics.
2.	Explain how to design                                                                     Familiarity         		None
	 software to
	 support forensics.
3.	Describe the legal                                                                        Familiarity         		None
	 requirements
	 for use of
	 seized data.
4.	Describe the process                                                                      Familiarity         		None
	 of evidence
	 seizure from
	 the time when
	 the requirement
	 was identified
	 to the disposition
	 of the data.
5.	Describe how data                                                                         Familiarity         		None
	 collection
	 is accomplished
	 and the proper
	 storage of
	 the original
	 and forensics
	 copy.
6.	Conduct data collection                                                                   Usage               		None
	 on a hard drive.
7.	Describe a person’s                                                                       Familiarity         		None
	 responsibility
	 and liability
	 while testifying
	 as a forensics
	 examiner.
8.	Recover data based                                                                        Usage               		None
	 on a given
	 search term
	 from an imaged
	 system.
9.	Reconstruct application                                                                   Usage               		None
	 history from
	 application
	 artifacts.
10.	Reconstruct web                                                                           Usage               		None
	 browsing history
	 from web artifacts.
11.	Capture and interpret                                                                     Usage               		None
	 network traffic.
12.	Discuss the challenges                                                                    Familiarity         		None
	 associated
	 with mobile
	 device forensics.
13.	Inspect a system                                                                          Usage               		None
	 (network, computer,
	 or application)
	 for the presence
	 of malware
	 or malicious
	 activity.
14.	Apply forensics                                                                           Usage               		None
	 tools to investigate
	 security breaches.
15.	Identify anti-forensic                                                                    Familiarity         		None
	 methods.
Foundational Concepts in Security                                                                 1.0/2.0			0.0/0.0
1.	Analyze the tradeoffs                                                                     Usage               		None
	 of balancing
	 key security
	 properties
	 (Confidentiality,
	 Integrity,
	 Availability).
2.	Describe the concepts                                                                     Familiarity         		None
	 of risk, threats,
	 vulnerabilities
	 and attack
	 vectors (including
	 the fact that
	 there is no
	 such thing
	 as perfect
	 security).
3.	Explain the concepts                                                                      Familiarity         		None
	 of authentication,
	 authorization,
	 access control.
4.	Explain the concept                                                                       Familiarity         		None
	 of trust and
	 trustworthiness.
5.	Recognize that there                                                                      Familiarity         		None
	 are important
	 ethical issues
	 to consider
	 in computer
	 security, including
	 ethical issues
	 associated
	 with fixing
	 or not fixing
	 vulnerabilities
	 and disclosing
	 or not disclosing
	 vulnerabilities.
Network Security                                                                                  0.0/2.0			0.0/0.0
1.	Describe the different                                                                    Familiarity         		None
	 categories
	 of network
	 threats and
	 attacks.
2.	Describe the architecture                                                                 Familiarity         		None
	 for public
	 and private
	 key cryptography
	 and how PKI
	 supports network
	 security.
3.	Describe virtues                                                                          Familiarity         		None
	 and limitations
	 of security
	 technologies
	 at each layer
	 of the network
	 stack.
4.	Identify the appropriate                                                                  Familiarity         		None
	 defense mechanism(s)
	 and its limitations
	 given a network
	 threat.
5.	Discuss security                                                                          Familiarity         		None
	 properties
	 and limitations
	 of other  non-wired
	 networks.
6.	Identify the additional                                                                   Familiarity         		None
	 threats faced
	 by non-wired
	 networks.
7.	Describe threats                                                                          Familiarity         		None
	 that can and
	 cannot be protected
	 against using
	 secure communication
	 channels.
8.	Summarize defenses                                                                        Familiarity         		None
	 against network
	 censorship.
9.	Diagram a network                                                                         Familiarity         		None
	 for security.
Platform Security                                                                                 0.0/0.0			0.0/0.0
1.	Explain the concept                                                                       Familiarity         		None
	 of code integrity
	 and code signing
	 and the scope
	 it applies
	 to.
2.	Discuss the concept                                                                       Familiarity         		None
	 of root of
	 trust and the
	 process of
	 secure boot
	 and secure
	 loading.
3.	Describe the mechanism                                                                    Familiarity         		None
	 of remote attestation
	 of system integrity.
4.	Summarize the goals                                                                       Familiarity         		None
	 and key primitives
	 of TPM.
5.	Identify the threats                                                                      Familiarity         		None
	 of plugging
	 peripherals
	 into a device.
6.	Identify physical                                                                         Familiarity         		None
	 attacks and
	 countermeasures.
7.	Identify attacks                                                                          Familiarity         		None
	 on non-PC hardware
	 platforms.
8.	Discuss the concept                                                                       Familiarity         		None
	 and importance
	 of trusted
	 path.
Principles of Secure Design                                                                       1.0/2.0			0.0/0.0
1.	Describe the principle                                                                    Familiarity         		None
	 of least privilege
	 and isolation
	 as applied
	 to system design.
2.	Summarize the principle                                                                   Familiarity         		None
	 of fail-safe
	 and deny-by-default.
3.	Discuss the implications                                                                  Familiarity         		None
	 of relying
	 on open design
	 or the secrecy
	 of design for
	 security. 
4.	Explain the goals                                                                         Familiarity         		None
	 of end-to-end
	 data security.
5.	Discuss the benefits                                                                      Familiarity         		None
	 of having multiple
	 layers of defenses.
6.	For each stage in                                                                         Familiarity         		None
	 the lifecycle
	 of a product,
	 describe what
	 security considerations
	 should be evaluated.
7.	Describe the cost                                                                         Familiarity         		None
	 and tradeoffs
	 associated
	 with designing
	 security into
	 a product.
8.	Describe the concept                                                                      Familiarity         		None
	 of mediation
	 and the principle
	 of complete
	 mediation.
9.	Be aware of standard                                                                      Familiarity         		None
	 components
	 for security
	 operations,
	 instead of
	 re-inventing
	 fundamentals
	 operations.
10.	Explain the concept                                                                       Familiarity         		None
	 of trusted
	 computing including
	 trusted computing
	 base and attack
	 surface and
	 the principle
	 of minimizing
	 trusted computing
	 base.
11.	Discuss the importance                                                                    Familiarity         		None
	 of usability
	 in security
	 mechanism design.
12.	Describe security                                                                         Familiarity         		None
	 issues that
	 arise at boundaries
	 between multiple
	 components.
	 
13.	Identify the different                                                                    Familiarity         		None
	 roles of prevention
	 mechanisms
	 and detection/deterrence
	 mechanisms.
Secure Software Engineering                                                                       0.0/0.0			0.0/0.0
1.	Describe the requirements                                                                 Familiarity         		None
	 for integrating
	 security into
	 the SDL.
2.	Apply the concepts                                                                        Usage               		None
	 of the Design
	 Principles
	 for Protection
	 Mechanisms,
	 the Principles
	 for Software
	 Security (Viega
	 and McGraw),
	 and the Principles
	 for Secure
	 Design (Morrie
	 Gasser) on
	 a software
	 development
	 project.
3.	Develop specifications                                                                    Usage               		None
	 for a software
	 development
	 effort that
	 fully specify
	 functional
	 requirements
	 and identifies
	 the expected
	 execution paths.
4.	Describe software                                                                         Familiarity         		None
	 development
	 best practices
	 for minimizing
	 vulnerabilities
	 in programming
	 code.
5.	Conduct a security                                                                        Usage               		None
	 verification
	 and assessment
	 (static and
	 dynamic) of
	 a software
	 application.
Security Policy and Governance                                                                    0.0/1.0			0.0/0.0
1.	Describe the concept                                                                      Familiarity         		None
	 of privacy
	 including personally
	 private information,
	 potential violations
	 of privacy
	 due to security
	 mechanisms,
	 and describe
	 how privacy
	 protection
	 mechanisms
	 run in conflict
	 with security
	 mechanisms.
2.	Describe how an                                                                           Familiarity         		None
	 attacker can
	 infer a secret
	 by interacting
	 with a database.
3.	Explain how to set                                                                        Familiarity         		None
	 a data backup
	 policy or password
	 refresh policy.
4.	Discuss how to set                                                                        Familiarity         		None
	 a breach disclosure
	 policy.
5.	Describe the consequences                                                                 Familiarity         		None
	 of data retention
	 policies.
6.	Identify the risks                                                                        Familiarity         		None
	 of relying
	 on outsourced
	 manufacturing.
7.	Identify the risks                                                                        Familiarity         		None
	 and benefits
	 of outsourcing
	 to the cloud.
Threats and Attacks                                                                               0.0/0.0			0.0/0.0
1.	Describe likely                                                                           Familiarity         		None
	 attacker types
	 against a particular
	 system.
2.	Discuss the limitations                                                                   Familiarity         		None
	 of malware
	 countermeasures
	 (eg, signature-based
	 detection,
	 behavioral
	 detection).
3.	Identify instances                                                                        Familiarity         		None
	 of social engineering
	 attacks and
	 Denial of Service
	 attacks.
4.	Discuss how Denial                                                                        Familiarity         		None
	 of Service
	 attacks can
	 be identified
	 and mitigated.
5.	Describe risks to                                                                         Familiarity         		None
	 privacy and
	 anonymity in
	 commonly used
	 applications.
6.	Discuss the concepts                                                                      Familiarity         		None
	 of covert channels
	 and other data
	 leakage procedures.
Web Security                                                                                      0.0/0.0			0.0/0.0
1.	Describe the browser                                                                      Familiarity         		None
	 security model
	 including same-origin
	 policy and
	 threat models
	 in web security.
2.	Discuss the concept                                                                       Familiarity         		None
	 of web sessions,
	 secure communication
	 channels such
	 as TLS and
	 importance
	 of secure certificates,
	 authentication
	 including single
	 sign-on such
	 as OAuth and
	 SAML.
3.	Investigate common                                                                        Familiarity         		None
	 types of vulnerabilities
	 and attacks
	 in web applications,
	 and defenses
	 against them.
4.	Use client-side                                                                           Usage               		None
	 security capabilities.

IM- Information Management
Data Mining                                                                                       0.0/0.0			0.0/0.0
1.	Compare and contrast                                                                      Assessment          		None
	 different uses
	 of data mining
	 as evidenced
	 in both research
	 and application.
2.	Explain the value                                                                         Familiarity         		None
	 of finding
	 associations
	 in market basket
	 data.
3.	Characterize the                                                                          Assessment          		None
	 kinds of patterns
	 that can be
	 discovered
	 by association
	 rule mining.
4.	Describe how to                                                                           Familiarity         		None
	 extend a relational
	 system to find
	 patterns using
	 association
	 rules.
5.	Evaluate different                                                                        Assessment          		None
	 methodologies
	 for effective
	 application
	 of data mining.
6.	Identify and characterize                                                                 Assessment          		None
	 sources of
	 noise, redundancy,
	 and outliers
	 in presented
	 data.
7.	Identify mechanisms                                                                       Familiarity         		None
	 (on-line aggregation,
	 anytime behavior,
	 interactive
	 visualization)
	 to close the
	 loop in the
	 data mining
	 process.
8.	Describe why the                                                                          Familiarity         		None
	 various close-the-loop
	 processes improve
	 the effectiveness
	 of data mining.
Data Modeling                                                                                     0.0/4.0			0.0/0.0
1.	Compare and contrast                                                                      Assessment          		None
	 appropriate
	 data models,
	 including internal
	 structures,
	 for different
	 types of data.
2.	Describe concepts                                                                         Familiarity         		None
	 in modeling
	 notation (eg,
	 Entity-Relation
	 Diagrams or
	 UML) and how
	 they would
	 be used.
3.	Define the fundamental                                                                    Familiarity         		None
	 terminology
	 used in the
	 relational
	 data model.
4.	Describe the basic                                                                        Familiarity         		None
	 principles
	 of the relational
	 data model.
5.	Apply the modeling                                                                        Usage               		None
	 concepts and
	 notation of
	 the relational
	 data model.
6.	Describe the main                                                                         Familiarity         		None
	 concepts of
	 the OO model
	 such as object
	 identity, type
	 constructors,
	 encapsulation,
	 inheritance,
	 polymorphism,
	 and versioning.
7.	Describe the differences                                                                  Assessment          		None
	 between relational
	 and semi-structured
	 data models.
8.	Give a semi-structured                                                                    Usage               		None
	 equivalent
	 (eg, in DTD
	 or XML Schema)
	 for a given
	 relational
	 schema.
Database Systems                                                                                  0.0/3.0			0.0/0.0
1.	Explain the characteristics                                                               Familiarity         		None
	 that distinguish
	 the database
	 approach from
	 the approach
	 of programming
	 with data files.
2.	Describe the most                                                                         Familiarity         		None
	 common designs
	 for core database
	 system components
	 including the
	 query optimizer,
	 query executor,
	 storage manager,
	 access methods,
	 and transaction
	 processor.
3.	Cite the basic goals,                                                                     Familiarity         		None
	 functions,
	 and models
	 of database
	 systems.
4.	Describe the components                                                                   Familiarity         		None
	 of a database
	 system and
	 give examples
	 of their use.
5.	Identify major DBMS                                                                       Familiarity         		None
	 functions and
	 describe their
	 role in a database
	 system.
6.	Explain the concept                                                                       Familiarity         		None
	 of data independence
	 and its importance
	 in a database
	 system.
7.	Use a declarative                                                                         Usage               		None
	 query language
	 to elicit information
	 from a database.
8.	Describe facilities                                                                       Familiarity         		None
	 that datatbases
	 provide supporting
	 structures
	 and/or stream
	 (sequence)
	 data, eg, text.
9.	Describe major approaches                                                                 Familiarity         		None
	 to storing
	 and processing
	 large volumes
	 of data.
Distributed Databases                                                                             0.0/0.0			0.0/0.0
1.	Explain the techniques                                                                    Familiarity         		None
	 used for data
	 fragmentation,
	 replication,
	 and allocation
	 during the
	 distributed
	 database design
	 process.
2.	Evaluate simple                                                                           Assessment          		None
	 strategies
	 for executing
	 a distributed
	 query to select
	 the strategy
	 that minimizes
	 the amount
	 of data transfer.
3.	Explain how the                                                                           Familiarity         		None
	 two-phase commit
	 protocol is
	 used to deal
	 with committing
	 a transaction
	 that accesses
	 databases stored
	 on multiple
	 nodes.
4.	Describe distributed                                                                      Familiarity         		None
	 concurrency
	 control based
	 on the distinguished
	 copy techniques
	 and the voting
	 method.
5.	Describe the three                                                                        Familiarity         		None
	 levels of software
	 in the client-server
	 model.
Indexing                                                                                          1.0/2.0			0.0/0.0
1.	Generate an index                                                                         Usage               		None
	 file for a
	 collection
	 of resources.
2.	Explain the role                                                                          Familiarity         		None
	 of an inverted
	 index in locating
	 a document
	 in a collection.
3.	Explain how stemming                                                                      Familiarity         		None
	 and stop words
	 affect indexing.
4.	Identify appropriate                                                                      Usage               		None
	 indices for
	 given relational
	 schema and
	 query set.
5.	Estimate time to                                                                          Usage               		None
	 retrieve information,
	 when indices
	 are used compared
	 to when they
	 are not used.
6.	Describe key challenges                                                                   Familiarity         		None
	 in web crawling,
	 eg, detecting
	 duplicate documents,
	 determining
	 the crawling
	 frontier.
Information Management Concepts                                                                   0.0/0.0			0.0/0.0
1.	Describe how humans                                                                       Familiarity         		None
	 gain access
	 to information
	 and data to
	 support their
	 needs.
2.	Describe the advantages                                                                   Assessment          		None
	 and disadvantages
	 of central
	 organizational
	 control over
	 data. 
3.	Identify the careers/roles                                                                Familiarity         		None
	 associated
	 with information
	 management
	 (eg, database
	 administrator,
	 data modeler,
	 application
	 developer,
	 end-user).
4.	Compare and contrast                                                                      Assessment          		None
	 information
	 with data and
	 knowledge.
5.	Demonstrate uses                                                                          Usage               		None
	 of explicitly
	 stored metadata/schema
	 associated
	 with data.
6.	Identify issues                                                                           Familiarity         		None
	 of data persistence
	 for an organization.
7.	Critique an information                                                                   Assessment          		None
	 application
	 with regard
	 to satisfying
	 user information
	 needs.
8.	Explain uses of                                                                           Familiarity         		None
	 declarative
	 queries.
9.	Give a declarative                                                                        Familiarity         		None
	 version for
	 a navigational
	 query.
10.	Describe several                                                                          Familiarity         		None
	 technical solutions
	 to the problems
	 related to
	 information
	 privacy, integrity,
	 security, and
	 preservation.
11.	Explain measures                                                                          Familiarity         		None
	 of efficiency
	 (throughput,
	 response time)
	 and effectiveness
	 (recall, precision).
12.	Describe approaches                                                                       Familiarity         		None
	 to scale up
	 information
	 systems.
13.	Identify vulnerabilities                                                                  Usage               		None
	 and failure
	 scenarios in
	 common forms
	 of information
	 systems.
Information Storage and Retrieval                                                                 0.0/0.0			0.0/0.0
1.	Explain basic information                                                                 Familiarity         		None
	 storage and
	 retrieval concepts.
2.	Describe what issues                                                                      Familiarity         		None
	 are specific
	 to efficient
	 information
	 retrieval.
3.	Give applications                                                                         Assessment          		None
	 of alternative
	 search strategies
	 and explain
	 why the particular
	 search strategy
	 is appropriate
	 for the application.
4.	Design and implement                                                                      Usage               		None
	 a small to
	 medium size
	 information
	 storage and
	 retrieval system,
	 or digital
	 library.
5.	Describe some of                                                                          Familiarity         		None
	 the technical
	 solutions to
	 the problems
	 related to
	 archiving and
	 preserving
	 information
	 in a digital
	 library.
Multimedia Systems                                                                                0.0/0.0			0.0/0.0
1.	Describe the media                                                                        Familiarity         		None
	 and supporting
	 devices commonly
	 associated
	 with multimedia
	 information
	 and systems.
2.	Demonstrate the                                                                           Usage               		None
	 use of content-based
	 information
	 analysis in
	 a multimedia
	 information
	 system.
3.	Critique multimedia                                                                       Assessment          		None
	 presentations
	 in terms of
	 their appropriate
	 use of audio,
	 video, graphics,
	 color, and
	 other information
	 presentation
	 concepts.
4.	Implement a multimedia                                                                    Usage               		None
	 application
	 using an authoring
	 system.
5.	For each of several                                                                       Familiarity         		None
	 media or multimedia
	 standards,
	 describe in
	 non-technical
	 language what
	 the standard
	 calls for,
	 and explain
	 how aspects
	 of human perception
	 might be sensitive
	 to the limitations
	 of that standard.
6.	Describe the characteristics                                                              Familiarity         		None
	 of a computer
	 system (including
	 identification
	 of support
	 tools and appropriate
	 standards)
	 that has to
	 host the implementation
	 of one of a
	 range of possible
	 multimedia
	 applications.
Physical Database Design                                                                          0.0/0.0			0.0/0.0
1.	Explain the concepts                                                                      Familiarity         		None
	 of records,
	 record types,
	 and files,
	 as well as
	 the different
	 techniques
	 for placing
	 file records
	 on disk.
2.	Give examples of                                                                          Familiarity         		None
	 the application
	 of primary,
	 secondary,
	 and clustering
	 indexes.
3.	Distinguish between                                                                       Assessment          		None
	 a non-dense
	 index and a
	 dense index.
4.	Implement dynamic                                                                         Usage               		None
	 multilevel
	 indexes using
	 B-trees.
5.	Explain the theory                                                                        Familiarity         		None
	 and application
	 of internal
	 and external
	 hashing techniques.
6.	Use hashing to facilitate                                                                 Usage               		None
	 dynamic file
	 expansion.
7.	Describe the relationships                                                                Familiarity         		None
	 among hashing,
	 compression,
	 and efficient
	 database searches.
8.	Evaluate costs and                                                                        Assessment          		None
	 benefits of
	 various hashing
	 schemes.
9.	Explain how physical                                                                      Familiarity         		None
	 database design
	 affects database
	 transaction
	 efficiency.
Query Languages                                                                                   0.0/0.0			0.0/0.0
1.	Create a relational                                                                       Usage               		None
	 database schema
	 in SQL that
	 incorporates
	 key, entity
	 integrity,
	 and referential
	 integrity constraints.
2.	Use SQL to create                                                                         Usage               		None
	 tables and
	 retrieve (SELECT)
	 information
	 from a database.
3.	Evaluate a set of                                                                         Assessment          		None
	 query processing
	 strategies
	 and select
	 the optimal
	 strategy.
4.	Create a non-procedural                                                                   Usage               		None
	 query by filling
	 in templates
	 of relations
	 to construct
	 an example
	 of the desired
	 query result.
5.	Embed object-oriented                                                                     Usage               		None
	 queries into
	 a stand-alone
	 language such
	 as C++ or Java
	 (eg, SELECT
	 ColMethod()
	 FROM Object).
6.	Write a stored procedure                                                                  Usage               		None
	 that deals
	 with parameters
	 and has some
	 control flow,
	 to provide
	 a given functionality.
Relational Databases                                                                              0.0/0.0			0.0/0.0
1.	Prepare a relational                                                                      Usage               		None
	 schema from
	 a conceptual
	 model developed
	 using the entity-
	 relationship
	 model.
2.	Explain and demonstrate                                                                   Usage               		None
	 the concepts
	 of entity integrity
	 constraint
	 and referential
	 integrity constraint
	 (including
	 definition
	 of the concept
	 of a foreign
	 key).
3.	Demonstrate use                                                                           Usage               		None
	 of the relational
	 algebra operations
	 from mathematical
	 set theory
	 (union, intersection,
	 difference,
	 and Cartesian
	 product) and
	 the relational
	 algebra operations
	 developed specifically
	 for relational
	 databases (select
	 (restrict),
	 project, join,
	 and division).
4.	Write queries in                                                                          Usage               		None
	 the relational
	 algebra.
5.	Write queries in                                                                          Usage               		None
	 the tuple relational
	 calculus.
6.	Determine the functional                                                                  Assessment          		None
	 dependency
	 between two
	 or more attributes
	 that are a
	 subset of a
	 relation.
7.	Connect constraints                                                                       Usage               		None
	 expressed as
	 primary key
	 and foreign
	 key, with functional
	 dependencies.
8.	Compute the closure                                                                       Usage               		None
	 of a set of
	 attributes
	 under given
	 functional
	 dependencies.
9.	Determine whether                                                                         Assessment          		None
	 a set of attributes
	 form a superkey
	 and/or candidate
	 key for a relation
	 with given
	 functional
	 dependencies.
10.	Evaluate a proposed                                                                       Assessment          		None
	 decomposition,
	 to say whether
	 it has lossless-join
	 and dependency-preservation.
11.	Describe the properties                                                                   Familiarity         		None
	 of BCNF, PJNF,
	 5NF.
12.	Explain the impact                                                                        Familiarity         		None
	 of normalization
	 on the efficiency
	 of database
	 operations
	 especially
	 query optimization.
13.	Describe what is                                                                          Familiarity         		None
	 a multi-valued
	 dependency
	 and what type
	 of constraints
	 it specifies.
Transaction Processing                                                                            0.0/0.0			0.0/0.0
1.	Create a transaction                                                                      Usage               		None
	 by embedding
	 SQL into an
	 application
	 program.
2.	Explain the concept                                                                       Familiarity         		None
	 of implicit
	 commits.
3.	Describe the issues                                                                       Familiarity         		None
	 specific to
	 efficient transaction
	 execution.
4.	Explain when and                                                                          Assessment          		None
	 why rollback
	 is needed and
	 how logging
	 assures proper
	 rollback.
5.	Explain the effect                                                                        Assessment          		None
	 of different
	 isolation levels
	 on the concurrency
	 control mechanisms.
6.	Choose the proper                                                                         Assessment          		None
	 isolation level
	 for implementing
	 a specified
	 transaction
	 protocol.
7.	Identify appropriate                                                                      Assessment          		None
	 transaction
	 boundaries
	 in application
	 programs.

IS- Intelligent Systems
Advanced Machine Learning                                                                         0.0/0.0			0.0/0.0
1.	Explain the differences                                                                   Familiarity         		None
	 among the three
	 main styles
	 of learning:
	 supervised,
	 reinforcement,
	 and unsupervised.
2.	Implement simple                                                                          Usage               		None
	 algorithms
	 for supervised
	 learning, reinforcement
	 learning, and
	 unsupervised
	 learning.
3.	Determine which                                                                           Usage               		None
	 of the three
	 learning styles
	 is appropriate
	 to a particular
	 problem domain.
4.	Compare and contrast                                                                      Assessment          		None
	 each of the
	 following techniques,
	 providing examples
	 of when each
	 strategy is
	 superior: decision
	 trees, neural
	 networks, and
	 belief networks.
5.	Evaluate the performance                                                                  Assessment          		None
	 of a simple
	 learning system
	 on a real-world
	 dataset.
6.	Characterize the                                                                          Familiarity         		None
	 state of the
	 art in learning
	 theory, including
	 its achievements
	 and its shortcomings.
7.	Explain the problem                                                                       Usage               		None
	 of overfitting,
	 along with
	 techniques
	 for detecting
	 and managing
	 the problem.
Advanced Represenation and Reasoning                                                              0.0/0.0			0.0/0.0
1.	Compare and contrast                                                                      Assessment          		None
	 the most common
	 models used
	 for structured
	 knowledge representation,
	 highlighting
	 their strengths
	 and weaknesses.
2.	Identify the components                                                                   Familiarity         		None
	 of non-monotonic
	 reasoning and
	 its usefulness
	 as a representational
	 mechanisms
	 for belief
	 systems.
3.	Compare and contrast                                                                      Assessment          		None
	 the basic techniques
	 for representing
	 uncertainty.
4.	Compare and contrast                                                                      Assessment          		None
	 the basic techniques
	 for qualitative
	 representation.
5.	Apply situation                                                                           Usage               		None
	 and event calculus
	 to problems
	 of action and
	 change.
6.	Explain the distinction                                                                   Familiarity         		None
	 between temporal
	 and spatial
	 reasoning,
	 and how they
	 interrelate.
7.	Explain the difference                                                                    Familiarity         		None
	 between rule-based,
	 case-based
	 and model-based
	 reasoning techniques.
8.	Define the concept                                                                        Familiarity         		None
	 of a planning
	 system and
	 how it differs
	 from classical
	 search techniques.
9.	Describe the differences                                                                  Familiarity         		None
	 between planning
	 as search,
	 operator-based
	 planning, and
	 propositional
	 planning, providing
	 examples of
	 domains where
	 each is most
	 applicable.
10.	Explain the distinction                                                                   Familiarity         		None
	 between monotonic
	 and non-monotonic
	 inference.
Advanced Search                                                                                   0.0/0.0			0.0/0.0
1.	Design and implement                                                                      Usage               		None
	 a genetic algorithm
	 solution to
	 a problem.
2.	Design and implement                                                                      Usage               		None
	 a simulated
	 annealing schedule
	 to avoid local
	 minima in a
	 problem.
3.	Design and implement                                                                      Usage               		None
	 A*/beam search
	 to solve a
	 problem.
4.	Apply minimax search                                                                      Usage               		None
	 with alpha-beta
	 pruning to
	 prune search
	 space in a
	 two-player
	 game.
5.	Compare and contrast                                                                      Assessment          		None
	 genetic algorithms
	 with classic
	 search techniques.
6.	Compare and contrast                                                                      Assessment          		None
	 various heuristic
	 searches vis-a-vis
	 applicability
	 to a given
	 problem.
Agents                                                                                            0.0/0.0			0.0/0.0
1.	List the defining                                                                         Familiarity         		None
	 characteristics
	 of an intelligent
	 agent.
2.	Characterize and                                                                          Assessment          		None
	 contrast the
	 standard agent
	 architectures.
3.	Describe the applications                                                                 Familiarity         		None
	 of agent theory
	 to domains
	 such as software
	 agents, personal
	 assistants,
	 and believable
	 agents.
4.	Describe the primary                                                                      Familiarity         		None
	 paradigms used
	 by learning
	 agents.
5.	Demonstrate using                                                                         Usage               		None
	 appropriate
	 examples how
	 multi-agent
	 systems support
	 agent interaction.
Basic Knowledge Representation and Reasoning                                                      0.0/3.0			0.0/0.0
1.	Translate a natural                                                                       Usage               		None
	 language (eg,
	 English) sentence
	 into predicate
	 logic statement.
2.	Convert a logic                                                                           Usage               		None
	 statement into
	 clause form.
3.	Apply resolution                                                                          Usage               		None
	 to a set of
	 logic statements
	 to answer a
	 query.
4.	Make a probabilistic                                                                      Usage               		None
	 inference in
	 a real-world
	 problem using
	 Bayes’ theorem
	 to determine
	 the probability
	 of a hypothesis
	 given evidence.
Basic Machine Learning                                                                            0.0/2.0			0.0/0.0
1.	List the differences                                                                      Familiarity         		None
	 among the three
	 main styles
	 of learning:
	 supervised,
	 reinforcement,
	 and unsupervised.
2.	Identify examples                                                                         Familiarity         		None
	 of classification
	 tasks, including
	 the available
	 input features
	 and output
	 to be predicted.
3.	Explain the difference                                                                    Familiarity         		None
	 between inductive
	 and deductive
	 learning.
4.	Describe over-fitting                                                                     Familiarity         		None
	 in the context
	 of a problem.
5.	Apply the simple                                                                          Usage               		None
	 statistical
	 learning algorithm
	 such as Naive
	 Bayesian Classifier
	 to a classification
	 task and measure
	 the classifier's
	 accuracy.
Basic Search Strategies                                                                           0.0/4.0			0.0/0.0
1.	Formulate an efficient                                                                    Usage               		None
	 problem space
	 for a problem
	 expressed in
	 natural language
	 (eg, English)
	 in terms of
	 initial and
	 goal states,
	 and operators.
2.	Describe the role                                                                         Familiarity         		None
	 of heuristics
	 and describe
	 the trade-offs
	 among completeness,
	 optimality,
	 time complexity,
	 and space complexity.
3.	Describe the problem                                                                      Familiarity         		None
	 of combinatorial
	 explosion of
	 search space
	 and its consequences.
4.	Select and implement                                                                      Usage               		None
	 an appropriate
	 uninformed
	 search algorithm
	 for a problem,
	 and characterize
	 its time and
	 space complexities.
5.	Select and implement                                                                      Usage               		None
	 an appropriate
	 informed search
	 algorithm for
	 a problem by
	 designing the
	 necessary heuristic
	 evaluation
	 function.
6.	Evaluate whether                                                                          Assessment          		None
	 a heuristic
	 for a given
	 problem is
	 admissible/can
	 guarantee optimal
	 solution.
7.	Formulate a problem                                                                       Usage               		None
	 specified in
	 natural language
	 (eg, English)
	 as a constraint
	 satisfaction
	 problem and
	 implement it
	 using a chronological
	 backtracking
	 algorithm or
	 stochastic
	 local search.
8.	Compare and contrast                                                                      Familiarity         		None
	 basic search
	 issues with
	 game playing
	 issues.
Fundamental Issues                                                                                0.0/1.0			0.0/0.0
1.	Describe Turing                                                                           Familiarity         		None
	 test and the
	 Chinese Room
	 thought experiment.
2.	Differentiate between                                                                     Familiarity         		None
	 the concepts
	 of optimal
	 reasoning/behavior
	 and human-like
	 reasoning/behavior.
3.	Determing the characteristics                                                             Assessment          		None
	 of a given
	 problem that
	 an intelligent
	 systems must
	 solve.
Natural Language Processing                                                                       0.0/0.0			0.0/0.0
1.	Define and contrast                                                                       Assessment          		None
	 deterministic
	 and stochastic
	 grammars, providing
	 examples to
	 show the adequacy
	 of each.
2.	Simulate, apply,                                                                          Usage               		None
	 or implement
	 classic and
	 stochastic
	 algorithms
	 for parsing
	 natural language.
3.	Identify the challenges                                                                   Familiarity         		None
	 of representing
	 meaning.
4.	List the advantages                                                                       Familiarity         		None
	 of using standard
	 corpora  Identify
	 examples of
	 current corpora
	 for a variety
	 of NLP tasks.
5.	Identify techniques                                                                       Familiarity         		None
	 for information
	 retrieval,
	 language translation,
	 and text classification.
Perception and Computer Vision                                                                    0.0/0.0			0.0/0.0
1.	Summarize the importance                                                                  Familiarity         		None
	 of image and
	 object recognition
	 in AI and indicate
	 several significant
	 applications
	 of this technology.
2.	List at least three                                                                       Familiarity         		None
	 image-segmentation
	 approaches,
	 such as thresholding,
	 edge-based
	 and region-based
	 algorithms,
	 along with
	 their defining
	 characteristics,
	 strengths,
	 and weaknesses.
3.	Implement 2d object                                                                       Usage               		None
	 recognition
	 based on contour-
	 and/or region-based
	 shape representations.
4.	Distinguish the                                                                           Familiarity         		None
	 goals of sound-recognition,
	 speech-recognition,
	 and speaker-recognition
	 and identify
	 how the raw
	 audio signal
	 will be handled
	 differently
	 in each of
	 these cases.
5.	Provide at least                                                                          Familiarity         		None
	 two examples
	 of a transformation
	 of a data source
	 from one sensory
	 domain to another,
	 eg, tactile
	 data interpreted
	 as single-band
	 2d images.
6.	Implement a feature-extraction                                                            Usage               		None
	 algorithm on
	 real data,
	 eg, an edge
	 or corner detector
	 for images
	 or vectors
	 of Fourier
	 coefficients
	 describing
	 a short slice
	 of audio signal.
7.	Implement an algorithm                                                                    Usage               		None
	 combining features
	 into higher-level
	 percepts, eg,
	 a contour or
	 polygon from
	 visual primitives
	 or phoneme
	 hypotheses
	 from an audio
	 signal.
8.	Implement a classification                                                                Usage               		None
	 algorithm that
	 segments input
	 percepts into
	 output categories
	 and quantitatively
	 evaluates the
	 resulting classification.
9.	Evaluate the performance                                                                  Assessment          		None
	 of the underlying
	 feature-extraction,
	 relative to
	 at least one
	 alternative
	 possible approach
	 (whether implemented
	 or not) in
	 its contribution
	 to the classification
	 task (8), above.
10.	Describe at least                                                                         Familiarity         		None
	 three classification
	 approaches,
	 their prerequisites
	 for applicability,
	 their strengths,
	 and their shortcomings.
Reasoning Under Uncertainty                                                                       0.0/0.0			0.0/0.0
1.	Apply Bayes’ rule                                                                         Usage               		None
	 to determine
	 the probability
	 of a hypothesis
	 given evidence.
2.	Explain how conditional                                                                   Assessment          		None
	 independence
	 assertions
	 allow for greater
	 efficiency
	 of probabilistic
	 systems.
3.	Identify examples                                                                         Familiarity         		None
	 of knowledge
	 representations
	 for reasoning
	 under uncertainty.
4.	State the complexity                                                                      Familiarity         		None
	 of exact inference
	  Identify methods
	 for approximate
	 inference.
5.	Design and implement                                                                      Usage               		None
	 at least one
	 knowledge representation
	 for reasoning
	 under uncertainty.
6.	Describe the complexities                                                                 Familiarity         		None
	 of temporal
	 probabilistic
	 reasoning.
7.	Design and implement                                                                      Usage               		None
	 an HMM as one
	 example of
	 a temporal
	 probabilistic
	 system.
8.	Describe the relationship                                                                 Familiarity         		None
	 between preferences
	 and utility
	 functions.
9.	Explain how utility                                                                       Assessment          		None
	 functions and
	 probabilistic
	 reasoning can
	 be combined
	 to make rational
	 decisions.
Robotics                                                                                          0.0/0.0			0.0/0.0
1.	List capabilities                                                                         Familiarity         		None
	 and limitations
	 of today's
	 state-of-the-art
	 robot systems,
	 including their
	 sensors and
	 the crucial
	 sensor processing
	 that informs
	 those systems.
2.	Integrate sensors,                                                                        Usage               		None
	 actuators,
	 and software
	 into a robot
	 designed to
	 undertake some
	 task.
3.	Program a robot                                                                           Usage               		None
	 to accomplish
	 simple tasks
	 using deliberative,
	 reactive, and/or
	 hybrid control
	 architectures.
4.	Implement fundamental                                                                     Usage               		None
	 motion planning
	 algorithms
	 within a robot
	 configuration
	 space.
5.	Characterize the                                                                          Familiarity         		None
	 uncertainties
	 associated
	 with common
	 robot sensors
	 and actuators;
	 articulate
	 strategies
	 for mitigating
	 these uncertainties.
6.	List the differences                                                                      Familiarity         		None
	 among robots'
	 representations
	 of their external
	 environment,
	 including their
	 strengths and
	 shortcomings.
7.	Compare and contrast                                                                      Assessment          		None
	 at least three
	 strategies
	 for robot navigation
	 within known
	 and/or unknown
	 environments,
	 including their
	 strengths and
	 shortcomings.
8.	Describe at least                                                                         Familiarity         		None
	 one approach
	 for coordinating
	 the actions
	 and sensing
	 of several
	 robots to accomplish
	 a single task.

NC- Networking and Communications
Introduction                                                                                      1.5/0.0			0.0/0.0
1.	Articulate the organization                                                               Familiarity         		None
	 of the Internet.
2.	List and define                                                                           Familiarity         		None
	 the appropriate
	 network terminology.
3.	Describe the layered                                                                      Familiarity         		None
	 structure of
	 a typical networked
	 architecture.
4.	Identify the different                                                                    Familiarity         		None
	 types of complexity
	 in a network
	 (edges, core,
	 etc).
Local Area Networks                                                                               0.0/1.5			0.0/0.0
1.	Describe how frames                                                                       Familiarity         		None
	 are forwarded
	 in an Ethernet
	 network.
2.	Describe the differences                                                                  Familiarity         		None
	 between IP
	 and Ethernet.
3.	Describe the interrelations                                                               Familiarity         		None
	 between IP
	 and Ethernet.
4.	Describe the steps                                                                        Familiarity         		None
	 used in one
	 common approach
	 to the multiple
	 access problem.
Mobility                                                                                          0.0/1.0			0.0/0.0
1.	Describe the organization                                                                 Familiarity         		None
	 of a wireless
	 network.
2.	Describe how wireless                                                                     Familiarity         		None
	 networks support
	 mobile users.
Networked Applications                                                                            1.5/0.0			0.0/0.0
1.	List the differences                                                                      Familiarity         		None
	 and the relations
	 between names
	 and addresses
	 in a network.
2.	Define the principles                                                                     Familiarity         		None
	 behind naming
	 schemes and
	 resource location.
3.	Implement a simple                                                                        Usage               		None
	 client-server
	 socket-based
	 application.
Reliable Data Delivery                                                                            0.0/2.0			0.0/0.0
1.	Describe the operation                                                                    Familiarity         		None
	 of reliable
	 delivery protocols.
2.	List the factors                                                                          Familiarity         		None
	 that affect
	 the performance
	 of reliable
	 delivery protocols.
3.	Design and implement                                                                      Usage               		None
	 a simple reliable
	 protocol.
Resource Allocation                                                                               0.0/1.0			0.0/0.0
1.	Describe how resources                                                                    Familiarity         		None
	 can be allocated
	 in a network.
2.	Describe the congestion                                                                   Familiarity         		None
	 problem in
	 a large network.
3.	Compare and contrast                                                                      Assessment          		None
	 fixed and dynamic
	 allocation
	 techniques.
4.	Compare and contrast                                                                      Assessment          		None
	 current approaches
	 to congestion.
Routing and Forwarding                                                                            0.0/1.5			0.0/0.0
1.	Describe the organization                                                                 Familiarity         		None
	 of the network
	 layer.
2.	Describe how packets                                                                      Familiarity         		None
	 are forwarded
	 in an IP network.
3.	List the scalability                                                                      Familiarity         		None
	 benefits of
	 hierarchical
	 addressing.
Social Networking                                                                                 0.0/0.0			0.0/0.0
1.	Discuss the key                                                                           Familiarity         		None
	 principles
	 (such as membership,
	 trust) of social
	 networking.
2.	Describe how existing                                                                     Familiarity         		None
	 social networks
	 operate.
3.	Construct a social                                                                        Usage               		None
	 network graph
	 from network
	 data.
4.	Analyze a social                                                                          Usage               		None
	 network to
	 determine who
	 the key people
	 are.
5.	Evaluate a given                                                                          Assessment          		None
	 interpretation
	 of a social
	 network question
	 with associated
	 data.

OS- Operating Systems
Concurrency                                                                                       0.0/3.0			0.0/0.0
1.	Describe the need                                                                         Familiarity         		None
	 for concurrency
	 within the
	 framework of
	 an operating
	 system.
2.	Demonstrate the                                                                           Usage               		None
	 potential run-time
	 problems arising
	 from the concurrent
	 operation of
	 many separate
	 tasks.
3.	Summarize the range                                                                       Familiarity         		None
	 of mechanisms
	 that can be
	 employed at
	 the operating
	 system level
	 to realize
	 concurrent
	 systems and
	 describe the
	 benefits of
	 each.
4.	Explain the different                                                                     Familiarity         		None
	 states that
	 a task may
	 pass through
	 and the data
	 structures
	 needed to support
	 the management
	 of many tasks.
5.	Summarize techniques                                                                      Familiarity         		None
	 for achieving
	 synchronization
	 in an operating
	 system (eg,
	 describe how
	 to implement
	 a semaphore
	 using OS primitives).
6.	Describe reasons                                                                          Familiarity         		None
	 for using interrupts,
	 dispatching,
	 and context
	 switching to
	 support concurrency
	 in an operating
	 system.
7.	Create state and                                                                          Usage               		None
	 transition
	 diagrams for
	 simple problem
	 domains.
Device Management                                                                                 0.0/0.0			0.0/0.0
1.	Explain the key                                                                           Familiarity         		None
	 difference
	 between serial
	 and parallel
	 devices and
	 identify the
	 conditions
	 in which each
	 is appropriate.
2.	Identify the relationship                                                                 Usage               		None
	 between the
	 physical hardware
	 and the virtual
	 devices maintained
	 by the operating
	 system.
3.	Explain buffering                                                                         Familiarity         		None
	 and describe
	 strategies
	 for implementing
	 it.
4.	Differentiate the                                                                         Usage               		None
	 mechanisms
	 used in interfacing
	 a range of
	 devices (including
	 hand-held devices,
	 networks, multimedia)
	 to a computer
	 and explain
	 the implications
	 of these for
	 the design
	 of an operating
	 system.
5.	Describe the advantages                                                                   Usage               		None
	 and disadvantages
	 of direct memory
	 access and
	 discuss the
	 circumstances
	 in which its
	 use is warranted.
6.	Identify the requirements                                                                 Familiarity         		None
	 for failure
	 recovery.
7.	Implement a simple                                                                        Usage               		None
	 device driver
	 for a range
	 of possible
	 devices.
Fault Tolerance                                                                                   0.0/0.0			0.0/0.0
1.	Explain the relevance                                                                     Familiarity         		None
	 of the terms
	 fault tolerance,
	 reliability,
	 and availability.
2.	Outline the range                                                                         Familiarity         		None
	 of methods
	 for implementing
	 fault tolerance
	 in an operating
	 system.
3.	Explain how an operating                                                                  Familiarity         		None
	 system can
	 continue functioning
	 after a fault
	 occurs.
File Systems                                                                                      0.0/0.0			0.0/0.0
1.	Describe the choices                                                                      Familiarity         		None
	 to be made
	 in designing
	 file systems.
2.	Compare and contrast                                                                      Usage               		None
	 different approaches
	 to file organization,
	 recognizing
	 the strengths
	 and weaknesses
	 of each.
3.	Summarize how hardware                                                                    Familiarity         		None
	 developments
	 have led to
	 changes in
	 the priorities
	 for the design
	 and the management
	 of file systems.
4.	Summarize the use                                                                         Familiarity         		None
	 of journaling
	 and how log-structured
	 file systems
	 enhance fault
	 tolerance.
Memory Management                                                                                 0.0/3.0			0.0/0.0
1.	Explain memory hierarchy                                                                  Familiarity         		None
	 and cost-performance
	 trade-offs.
2.	Summarize the principles                                                                  Familiarity         		None
	 of virtual
	 memory as applied
	 to caching
	 and paging.
3.	Evaluate the trade-offs                                                                   Assessment          		None
	 in terms of
	 memory size
	 (main memory,
	 cache memory,
	 auxiliary memory)
	 and processor
	 speed.
4.	Defend the different                                                                      Assessment          		None
	 ways of allocating
	 memory to tasks,
	 citing the
	 relative merits
	 of each.
5.	Describe the reason                                                                       Familiarity         		None
	 for and use
	 of cache memory
	 (performance
	 and proximity,
	 different dimension
	 of how caches
	 complicate
	 isolation and
	 VM abstraction).
6.	Discuss the concept                                                                       Familiarity         		None
	 of thrashing,
	 both in terms
	 of the reasons
	 it occurs and
	 the techniques
	 used to recognize
	 and manage
	 the problem.
Operating System Principles                                                                       2.0/0.0			0.0/0.0
1.	Explain the concept                                                                       Familiarity         		None
	 of a logical
	 layer.
2.	Explain the benefits                                                                      Familiarity         		None
	 of building
	 abstract layers
	 in hierarchical
	 fashion.
3.	Describe the value                                                                        Assessment          		None
	 of APIs and
	 middleware.
4.	Describe how computing                                                                    Familiarity         		None
	 resources are
	 used by application
	 software and
	 managed by
	 system software.
5.	Contrast kernel                                                                           Usage               		None
	 and user mode
	 in an operating
	 system.
6.	Discuss the advantages                                                                    Familiarity         		None
	 and disadvantages
	 of using interrupt
	 processing.
7.	Explain the use                                                                           Familiarity         		None
	 of a device
	 list and driver
	 I/O queue.
Overview of Operating Systems                                                                     2.0/0.0			0.0/0.0
1.	Explain the objectives                                                                    Familiarity         		None
	 and functions
	 of modern operating
	 systems.
2.	Analyze the tradeoffs                                                                     Usage               		None
	 inherent in
	 operating system
	 design.
3.	Describe the functions                                                                    Familiarity         		None
	 of a contemporary
	 operating system
	 with respect
	 to convenience,
	 efficiency,
	 and the ability
	 to evolve.
4.	Discuss networked,                                                                        Familiarity         		None
	 client-server,
	 distributed
	 operating systems
	 and how they
	 differ from
	 single user
	 operating systems.
5.	Identify potential                                                                        Familiarity         		None
	 threats to
	 operating systems
	 and the security
	 features design
	 to guard against
	 them.
Real Time and Embedded Systems                                                                    0.0/0.0			0.0/0.0
1.	Describe what makes                                                                       Familiarity         		None
	 a system a
	 real-time system.
2.	Explain the presence                                                                      Familiarity         		None
	 of and describe
	 the characteristics
	 of latency
	 in real-time
	 systems.
3.	Summarize special                                                                         Familiarity         		None
	 concerns that
	 real-time systems
	 present, including
	 risk, and how
	 these concerns
	 are addressed.
Scheduling and Dispatch                                                                           0.0/3.0			0.0/0.0
1.	Compare and contrast                                                                      Usage               		None
	 the common
	 algorithms
	 used for both
	 preemptive
	 and non-preemptive
	 scheduling
	 of tasks in
	 operating systems,
	 such as priority,
	 performance
	 comparison,
	 and fair-share
	 schemes.
2.	Describe relationships                                                                    Familiarity         		None
	 between scheduling
	 algorithms
	 and application
	 domains.
3.	Discuss the types                                                                         Familiarity         		None
	 of processor
	 scheduling
	 such as short-term,
	 medium-term,
	 long-term,
	 and I/O.
4.	Describe the difference                                                                   Usage               		None
	 between processes
	 and threads.
5.	Compare and contrast                                                                      Usage               		None
	 static and
	 dynamic approaches
	 to real-time
	 scheduling.
6.	Discuss the need                                                                          Familiarity         		None
	 for preemption
	 and deadline
	 scheduling.
7.	Identify ways that                                                                        Usage               		None
	 the logic embodied
	 in scheduling
	 algorithms
	 are applicable
	 to other domains,
	 such as disk
	 I/O, network
	 scheduling,
	 project scheduling,
	 and problems
	 beyond computing.
Security and Protection                                                                           0.0/2.0			0.0/0.0
1.	Articulate the need                                                                       Assessment          		None
	 for protection
	 and security
	 in an OS (cross
	 reference IAS/Security
	 Architecture
	 and Systems
	 Administration/Investigating
	 Operating Systems
	 Security for
	 various systems).
2.	Summarize the features                                                                    Familiarity         		None
	 and limitations
	 of an operating
	 system used
	 to provide
	 protection
	 and security
	 (cross reference
	 IAS/Security
	 Architecture
	 and Systems
	 Administration).
3.	Explain the mechanisms                                                                    Familiarity         		None
	 available in
	 an OS to control
	 access to resources
	 (cross reference
	 IAS/Security
	 Architecture
	 and Systems
	 Administration/Access
	 Control/Configuring
	 systems to
	 operate securely
	 as an IT system).
4.	Carry out simple                                                                          Usage               		None
	 system administration
	 tasks according
	 to a security
	 policy, for
	 example creating
	 accounts, setting
	 permissions,
	 applying patches,
	 and arranging
	 for regular
	 backups (cross
	 reference IAS/Security
	 Architecture
	 and Systems
	 Administration
	 ).
System Performance Evaluation                                                                     0.0/0.0			0.0/0.0
1.	Describe the performance                                                                  Familiarity         		None
	 measurements
	 used to determine
	 how a system
	 performs.
2.	Explain the main                                                                          Familiarity         		None
	 evaluation
	 models used
	 to evaluate
	 a system.
Virtual Machines                                                                                  0.0/0.0			0.0/0.0
1.	Explain the concept                                                                       Familiarity         		None
	 of virtual
	 memory and
	 how it is realized
	 in hardware
	 and software.
2.	Differentiate emulation                                                                   Familiarity         		None
	 and isolation.
3.	Evaluate virtualization                                                                   Assessment          		None
	 trade-offs.
4.	Discuss hypervisors                                                                       Usage               		None
	 and the need
	 for them in
	 conjunction
	 with different
	 types of hypervisors.

PBD- Platform-based Development
Game Platforms                                                                                    0.0/0.0			0.0/0.0
1.	Design and Implement                                                                      Usage               		None
	 a simple application
	 on a game platform.
2.	Describe the constraints                                                                  Familiarity         		None
	 that game platforms
	 impose on developers.
3.	Compare and contrast                                                                      Assessment          		None
	 game programming
	 with general
	 purpose programming.
Industrial Platforms                                                                              0.0/0.0			0.0/0.0
1.	Design and implement                                                                      Usage               		None
	 an industrial
	 application
	 on a given
	 platform (eg,
	 using Lego
	 Mindstorms
	 or Matlab).
2.	Compare and contrast                                                                      Assessment          		None
	 domain specific
	 languages with
	 general purpose
	 programming
	 languages.
3.	Discuss the constraints                                                                   Familiarity         		None
	 that a given
	 industrial
	 platforms impose
	 on developers.
Introduction                                                                                      0.0/0.0			0.0/0.0
1.	Describe how platform-based                                                               Familiarity         		None
	 development
	 differs from
	 general purpose
	 programming.
2.	List characteristics                                                                      Familiarity         		None
	 of platform
	 languages.
3.	Write and execute                                                                         Usage               		None
	 a simple platform-based
	 program.
4.	List the advantages                                                                       Familiarity         		None
	 and disadvantages
	 of programming
	 with platform
	 constraints.
Mobile Platforms                                                                                  0.0/0.0			0.0/0.0
1.	Design and implement                                                                      Usage               		None
	 a mobile application
	 for a given
	 mobile platform.
2.	Discuss the constraints                                                                   Familiarity         		None
	 that mobile
	 platforms put
	 on developers.
3.	Discuss the performance                                                                   Familiarity         		None
	 vs power tradeoff.
4.	Compare and Contrast                                                                      Assessment          		None
	 mobile programming
	 with general
	 purpose programming.
Web Platforms                                                                                     0.0/0.0			0.0/0.0
1.	Design and Implement                                                                      Usage               		None
	 a simple web
	 application.
2.	Describe the constraints                                                                  Familiarity         		None
	 that the web
	 puts on developers.
3.	Compare and contrast                                                                      Assessment          		None
	 web programming
	 with general
	 purpose programming.
4.	Describe the differences                                                                  Familiarity         		None
	 between Software-as-a-Service
	 and traditional
	 software products.
5.	Discuss how web                                                                           Familiarity         		None
	 standards impact
	 software development.
6.	Review an existing                                                                        Assessment          		None
	 web application
	 against a current
	 web standard.

PD- Parallel and Distributed Computing
Cloud Computing                                                                                   0.0/0.0			0.0/0.0
1.	Discuss the importance                                                                    Familiarity         		None
	 of elasticity
	 and resource
	 management
	 in cloud computing.
2.	Explain strategies                                                                        Familiarity         		None
	 to synchronize
	 a common view
	 of shared data
	 across a collection
	 of devices.
3.	Explain the advantages                                                                    Familiarity         		None
	 and disadvantages
	 of using virtualized
	 infrastructure.
4.	Deploy an application                                                                     Usage               		None
	 that uses cloud
	 infrastructure
	 for computing
	 and/or data
	 resources.
5.	Appropriately partition                                                                   Usage               		None
	 an application
	 between a client
	 and resources.
Communication and Coordination                                                                    1.0/3.0			0.0/0.0
1.	Use mutual exclusion                                                                      Usage               		None
	 to avoid a
	 given race
	 condition.
2.	Give an example                                                                           Familiarity         		None
	 of an ordering
	 of accesses
	 among concurrent
	 activities
	 (eg, program
	 with a data
	 race) that
	 is not sequentially
	 consistent.
3.	Give an example                                                                           Usage               		None
	 of a scenario
	 in which blocking
	 message sends
	 can deadlock.
4.	Explain when and                                                                          Familiarity         		None
	 why multicast
	 or event-based
	 messaging can
	 be preferable
	 to alternatives.
5.	Write a program                                                                           Usage               		None
	 that correctly
	 terminates
	 when all of
	 a set of concurrent
	 tasks have
	 completed.
6.	Use a properly synchronized                                                               Usage               		None
	 queue to buffer
	 data passed
	 among activities.
7.	Explain why checks                                                                        Familiarity         		None
	 for preconditions,
	 and actions
	 based on these
	 checks, must
	 share the same
	 unit of atomicity
	 to be effective.
8.	Write a test program                                                                      Usage               		None
	 that can reveal
	 a concurrent
	 programming
	 error; for
	 example, missing
	 an update when
	 two activities
	 both try to
	 increment a
	 variable.
9.	Describe at least                                                                         Familiarity         		None
	 one design
	 technique for
	 avoiding liveness
	 failures in
	 programs using
	 multiple locks
	 or semaphores.
10.	Describe the relative                                                                     Familiarity         		None
	 merits of optimistic
	 versus conservative
	 concurrency
	 control under
	 different rates
	 of contention
	 among updates.
11.	Give an example                                                                           Familiarity         		None
	 of a scenario
	 in which an
	 attempted optimistic
	 update may
	 never complete.
12.	Use semaphores or                                                                         Usage               		None
	 condition variables
	 to block threads
	 until a necessary
	 precondition
	 holds.
Distributed Systems                                                                               0.0/0.0			0.0/0.0
1.	Distinguish network                                                                       Familiarity         		None
	 faults from
	 other kinds
	 of failures.
2.	Explain why synchronization                                                               Familiarity         		None
	 constructs
	 such as simple
	 locks are not
	 useful in the
	 presence of
	 distributed
	 faults.
3.	Write a program                                                                           Usage               		None
	 that performs
	 any required
	 marshalling
	 and conversion
	 into message
	 units, such
	 as packets,
	 to communicate
	 interesting
	 data between
	 two hosts.
4.	Measure the observed                                                                      Usage               		None
	 throughput
	 and response
	 latency across
	 hosts in a
	 given network.
5.	Explain why no distributed                                                                Familiarity         		None
	 system can
	 be simultaneously
	 consistent,
	 available,
	 and partition
	 tolerant.
6.	Implement a simple                                                                        Usage               		None
	 server -- for
	 example, a
	 spell checking
	 service.
7.	Explain the tradeoffs                                                                     Familiarity         		None
	 among overhead,
	 scalability,
	 and fault tolerance
	 when choosing
	 a stateful
	 v stateless
	 design for
	 a given service.
8.	Describe the scalability                                                                  Familiarity         		None
	 challenges
	 associated
	 with a service
	 growing to
	 accommodate
	 many clients,
	 as well as
	 those associated
	 with a service
	 only transiently
	 having many
	 clients.
9.	Give examples of                                                                          Usage               		None
	 problems for
	 which consensus
	 algorithms
	 such as leader
	 election are
	 required.
Formal Models and Semantics                                                                       0.0/0.0			0.0/0.0
1.	Model a concurrent                                                                        Usage               		None
	 process using
	 a formal model,
	 such as pi-calculus.
2.	Explain the characteristics                                                               Familiarity         		None
	 of a particular
	 formal parallel
	 model.
3.	Formally model a                                                                          Usage               		None
	 shared memory
	 system to show
	 if it is consistent.
4.	Use a model to show                                                                       Usage               		None
	 progress guarantees
	 in a parallel
	 algorithm.
5.	Use formal techniques                                                                     Usage               		None
	 to show that
	 a parallel
	 algorithm is
	 correct with
	 respect to
	 a safety or
	 liveness property.
6.	Decide if a specific                                                                      Usage               		None
	 execution is
	 linearizable
	 or not.
Parallel Algorithms, Analysis, and Programming                                                    0.0/3.0			0.0/0.0
1.	Define critical                                                                           Familiarity         		None
	 path, work,
	 and span.
2.	Compute the work                                                                          Usage               		None
	 and span, and
	 determine the
	 critical path
	 with respect
	 to a parallel
	 execution diagram.
3.	Define speed-up                                                                           Familiarity         		None
	 and explain
	 the notion
	 of an algorithm’s
	 scalability
	 in this regard.
4.	Identify independent                                                                      Usage               		None
	 tasks in a
	 program that
	 may be parallelized.
5.	Characterize features                                                                     Familiarity         		None
	 of a workload
	 that allow
	 or prevent
	 it from being
	 naturally parallelized.
6.	Implement a parallel                                                                      Usage               		None
	 divide-and-conquer
	 (and/or graph
	 algorithm)
	 and empirically
	 measure its
	 performance
	 relative to
	 its sequential
	 analog.
7.	Decompose a problem                                                                       Usage               		None
	 (eg, counting
	 the number
	 of occurrences
	 of some word
	 in a document)
	 via map and
	 reduce operations.
8.	Provide an example                                                                        Familiarity         		None
	 of a problem
	 that fits the
	 producer-consumer
	 paradigm.
9.	Give examples of                                                                          Familiarity         		None
	 problems where
	 pipelining
	 would be an
	 effective means
	 of parallelization.
10.	Implement a parallel                                                                      Usage               		None
	 matrix algorithm.
11.	Identify issues                                                                           Familiarity         		None
	 that arise
	 in producer-consumer
	 algorithms
	 and mechanisms
	 that may be
	 used for addressing
	 them.
Parallel Architecture                                                                             1.0/2.0			0.0/0.0
1.	Explain the differences                                                                   Familiarity         		None
	 between shared
	 and distributed
	 memory.
2.	Describe the SMP                                                                          Familiarity         		None
	 architecture
	 and note its
	 key features.
3.	Characterize the                                                                          Familiarity         		None
	 kinds of tasks
	 that are a
	 natural match
	 for SIMD machines.
4.	Describe the advantages                                                                   Familiarity         		None
	 and limitations
	 of GPUs vs
	 CPUs.
5.	Explain the features                                                                      Familiarity         		None
	 of each classification
	 in Flynn’s
	 taxonomy.
6.	Describe assembly-level                                                                   Familiarity         		None
	 support for
	 atomic operations.
7.	Describe the challenges                                                                   Familiarity         		None
	 in maintaining
	 cache coherence.
8.	Describe the key                                                                          Familiarity         		None
	 performance
	 challenges
	 in different
	 memory and
	 distributed
	 system topologies.
Parallel Decomposition                                                                            1.0/2.0			0.0/0.0
1.	Explain why synchronization                                                               Usage               		None
	 is necessary
	 in a specific
	 parallel program.
2.	Identify opportunities                                                                    Familiarity         		None
	 to partition
	 a serial program
	 into independent
	 parallel modules.
3.	Write a correct                                                                           Usage               		None
	 and scalable
	 parallel algorithm.
4.	Parallelize an algorithm                                                                  Usage               		None
	 by applying
	 task-based
	 decomposition.
5.	Parallelize an algorithm                                                                  Usage               		None
	 by applying
	 data-parallel
	 decomposition.
6.	Write a program                                                                           Usage               		None
	 using actors
	 and/or reactive
	 processes.
Parallel Performance                                                                              0.0/0.0			0.0/0.0
1.	Detect and correct                                                                        Usage               		None
	 a load imbalance.
2.	Calculate the implications                                                                Usage               		None
	 of Amdahl’s
	 law for a particular
	 parallel algorithm
	 (cross-reference
	 SF/Evaluation
	 for Amdahl’s
	 Law).
3.	Describe how data                                                                         Familiarity         		None
	 distribution/layout
	 can affect
	 an algorithm’s
	 communication
	 costs.
4.	Detect and correct                                                                        Usage               		None
	 an instance
	 of false sharing.
5.	Explain the impact                                                                        Familiarity         		None
	 of scheduling
	 on parallel
	 performance.
6.	Explain performance                                                                       Familiarity         		None
	 impacts of
	 data locality.
7.	Explain the impact                                                                        Familiarity         		None
	 and trade-off
	 related to
	 power usage
	 on parallel
	 performance.
Parallelism Fundamentals                                                                          2.0/0.0			0.0/0.0
1.	Distinguish using                                                                         Familiarity         		None
	 computational
	 resources for
	 a faster answer
	 from managing
	 efficient access
	 to a shared
	 resource.
2.	Distinguish multiple                                                                      Familiarity         		None
	 sufficient
	 programming
	 constructs
	 for synchronization
	 that may be
	 inter-implementable
	 but have complementary
	 advantages.
3.	Distinguish data                                                                          Familiarity         		None
	 races from
	 higher level
	 races.

PL- Programming Languages
Advanced Programming Constructs                                                                   0.0/0.0			0.0/0.0
1.	Use various advanced                                                                      Usage               		None
	 programming
	 constructs
	 and idioms
	 correctly.
2.	Discuss how various                                                                       Familiarity         		None
	 advanced programming
	 constructs
	 aim to improve
	 program structure,
	 software quality,
	 and programmer
	 productivity.
3.	Discuss how various                                                                       Familiarity         		None
	 advanced programming
	 constructs
	 interact with
	 the definition
	 and implementation
	 of other language
	 features.
Basic Type Systems                                                                                1.0/4.0			0.0/0.0
1.	For both a primitive                                                                      Familiarity         		None
	 and a compound
	 type, informally
	 describe the
	 values that
	 have that type.
2.	For a language with                                                                       Familiarity         		None
	 a static type
	 system, describe
	 the operations
	 that are forbidden
	 statically,
	 such as passing
	 the wrong type
	 of value to
	 a function
	 or method.
3.	Describe examples                                                                         Familiarity         		None
	 of program
	 errors detected
	 by a type system.
4.	For multiple programming                                                                  Usage               		None
	 languages,
	 identify program
	 properties
	 checked statically
	 and program
	 properties
	 checked dynamically.
5.	Give an example                                                                           Familiarity         		None
	 program that
	 does not type-check
	 in a particular
	 language and
	 yet would have
	 no error if
	 run.
6.	Use types and type-error                                                                  Usage               		None
	 messages to
	 write and debug
	 programs.
7.	Explain how typing                                                                        Familiarity         		None
	 rules define
	 the set of
	 operations
	 that are legal
	 for a type.
8.	Write down the type                                                                       Usage               		None
	 rules governing
	 the use of
	 a particular
	 compound type.
9.	Explain why undecidability                                                                Familiarity         		None
	 requires type
	 systems to
	 conservatively
	 approximate
	 program behavior.
10.	Define and use program                                                                    Usage               		None
	 pieces (such
	 as functions,
	 classes, methods)
	 that use generic
	 types, including
	 for collections.
11.	Discuss the differences                                                                   Familiarity         		None
	 among generics,
	 subtyping,
	 and overloading.
12.	Explain multiple                                                                          Familiarity         		None
	 benefits and
	 limitations
	 of static typing
	 in writing,
	 maintaining,
	 and debugging
	 software.
Code Generation                                                                                   0.0/0.0			0.0/0.0
1.	Identify all essential                                                                    Familiarity         		None
	 steps for automatically
	 converting
	 source code
	 into assembly
	 or other low-level
	 languages.
2.	Generate the low-level                                                                    Usage               		None
	 code for calling
	 functions/methods
	 in modern languages.
3.	Discuss why separate                                                                      Familiarity         		None
	 compilation
	 requires uniform
	 calling conventions.
4.	Discuss why separate                                                                      Familiarity         		None
	 compilation
	 limits optimization
	 because of
	 unknown effects
	 of calls.
5.	Discuss opportunities                                                                     Familiarity         		None
	 for optimization
	 introduced
	 by naive translation
	 and approaches
	 for achieving
	 optimization,
	 such as instruction
	 selection,
	 instruction
	 scheduling,
	 register allocation,
	 and peephole
	 optimization.
Compiler Semantic Analysis                                                                        0.0/0.0			0.0/0.0
1.	Implement context-sensitive,                                                              Usage               		None
	 source-level
	 static analyses
	 such as type-checkers
	 or resolving
	 identifiers
	 to identify
	 their binding
	 occurrences.
2.	Describe semantic                                                                         Usage               		None
	 analyses using
	 an attribute
	 grammar.
Concurrency and Parallelism                                                                       0.0/0.0			0.0/0.0
1.	Write correct concurrent                                                                  Usage               		None
	 programs using
	 multiple programming
	 models, such
	 as shared memory,
	 actors, futures,
	 and data-parallelism
	 primitives.
2.	Use a message-passing                                                                     Usage               		None
	 model to analyze
	 a communication
	 protocol.
3.	Explain why programming                                                                   Familiarity         		None
	 languages do
	 not guarantee
	 sequential
	 consistency
	 in the presence
	 of data races
	 and what programmers
	 must do as
	 a result.
Event-Driven and Reactive Programming                                                             0.0/2.0			0.0/0.0
1.	Write event handlers                                                                      Usage               		None
	 for use in
	 reactive systems,
	 such as GUIs.
2.	Explain why an event-driven                                                               Familiarity         		None
	 programming
	 style is natural
	 in domains
	 where programs
	 react to external
	 events.
3.	Describe an interactive                                                                   Familiarity         		None
	 system in terms
	 of a model,
	 a view, and
	 a controller.
Formal Semantics                                                                                  0.0/0.0			0.0/0.0
1.	Give a formal semantics                                                                   Usage               		None
	 for a small
	 language.
2.	Write a lambda-calculus                                                                   Usage               		None
	 program and
	 show its evaluation
	 to a normal
	 form.
3.	Discuss the different                                                                     Familiarity         		None
	 approaches
	 of operational,
	 denotational,
	 and axiomatic
	 semantics.
4.	Use induction to                                                                          Usage               		None
	 prove properties
	 of all programs
	 in a language.
5.	Use induction to                                                                          Usage               		None
	 prove properaties
	 of all programs
	 in a language
	 that are well-typed
	 according to
	 a formally
	 defined type
	 system.
6.	Use parametricity                                                                         Usage               		None
	 to establish
	 the behavior
	 of code given
	 only its type.
7.	Use formal semantics                                                                      Usage               		None
	 to build a
	 formal model
	 of a software
	 system other
	 than a programming
	 language.
Functional Programming                                                                            3.0/4.0			0.0/0.0
1.	Write basic algorithms                                                                    Usage               		None
	 that avoid
	 assigning to
	 mutable state
	 or considering
	 reference equality.
2.	Write useful functions                                                                    Usage               		None
	 that take and
	 return other
	 functions.
3.	Compare and contrast                                                                      Assessment          		None
	 (1) the procedural/functional
	 approach—defining
	 a function
	 for each operation
	 with the function
	 body providing
	 a case for
	 each data variant—and
	 (2) the object-oriented
	 approach—defining
	 a class for
	 each data variant
	 with the class
	 definition
	 providing a
	 method for
	 each operation
	  Understand
	 both as defining
	 a matrix of
	 operations
	 and variants.
4.	Correctly reason                                                                          Usage               		None
	 about variables
	 and lexical
	 scope in a
	 program using
	 function closures.
5.	Use functional encapsulation                                                              Usage               		None
	 mechanisms
	 such as closures
	 and modular
	 interfaces.
6.	Define and use iterators                                                                  Usage               		None
	 and other operations
	 on aggregates,
	 including operations
	 that take functions
	 as arguments,
	 in multiple
	 programming
	 languages,
	 selecting the
	 most natural
	 idioms for
	 each language.
Language Pragmatics                                                                               0.0/0.0			0.0/0.0
1.	Discuss the role                                                                          Familiarity         		None
	 of concepts
	 such as orthogonality
	 and well-chosen
	 defaults in
	 language design.
2.	Use crisp and objective                                                                   Usage               		None
	 criteria for
	 evaluating
	 language-design
	 decisions.
3.	Give an example                                                                           Usage               		None
	 program whose
	 result can
	 differ under
	 different rules
	 for evaluation
	 order, precedence,
	 or associativity.
4.	Show uses of delayed                                                                      Familiarity         		None
	 evaluation,
	 such as user-defined
	 control abstractions.
5.	Discuss the need                                                                          Familiarity         		None
	 for allowing
	 calls to external
	 calls and system
	 libraries and
	 the consequences
	 for language
	 implementation.
Language Translation and Execution                                                                0.0/3.0			0.0/0.0
1.	Distinguish a language                                                                    Familiarity         		None
	 definition
	 (what constructs
	 mean) from
	 a particular
	 language implementation
	 (compiler vs
	 interpreter,
	 run-time representation
	 of data objects,
	 etc).
2.	Distinguish syntax                                                                        Familiarity         		None
	 and parsing
	 from semantics
	 and evaluation.
3.	Sketch a low-level                                                                        Familiarity         		None
	 run-time representation
	 of core language
	 constructs,
	 such as objects
	 or closures.
4.	Explain how programming                                                                   Familiarity         		None
	 language implementations
	 typically organize
	 memory into
	 global data,
	 text, heap,
	 and stack sections
	 and how features
	 such as recursion
	 and memory
	 management
	 map to this
	 memory model.
5.	Identify and fix                                                                          Usage               		None
	 memory leaks
	 and dangling-pointer
	 dereferences.
6.	Discuss the benefits                                                                      Familiarity         		None
	 and limitations
	 of garbage
	 collection,
	 including the
	 notion of reachability.
Logic Programming                                                                                 0.0/0.0			0.0/0.0
1.	Use a logic language                                                                      Usage               		None
	 to implement
	 a conventional
	 algorithm.
2.	Use a logic language                                                                      Usage               		None
	 to implement
	 an algorithm
	 employing implicit
	 search using
	 clauses, relations,
	 and cuts.
Object-Oriented Programming                                                                       4.0/6.0			0.0/0.0
1.	Design and implement                                                                      Usage               		None
	 a class.
2.	Use subclassing                                                                           Usage               		None
	 to design simple
	 class hierarchies
	 that allow
	 code to be
	 reused for
	 distinct subclasses.
3.	Correctly reason                                                                          Usage               		None
	 about control
	 flow in a program
	 using dynamic
	 dispatch.
4.	Compare and contrast                                                                      Assessment          		None
	 (1) the procedural/functional
	 approach—defining
	 a function
	 for each operation
	 with the function
	 body providing
	 a case for
	 each data variant—and
	 (2) the object-oriented
	 approach—defining
	 a class for
	 each data variant
	 with the class
	 definition
	 providing a
	 method for
	 each operation
	  Understand
	 both as defining
	 a matrix of
	 operations
	 and variants.
5.	Explain the relationship                                                                  Familiarity         		None
	 between object-oriented
	 inheritance
	 (code-sharing
	 and overriding)
	 and subtyping
	 (the idea of
	 a subtype being
	 usable in a
	 context that
	 expects the
	 supertype).
6.	Use object-oriented                                                                       Usage               		None
	 encapsulation
	 mechanisms
	 such as interfaces
	 and private
	 members.
7.	Define and use iterators                                                                  Usage               		None
	 and other operations
	 on aggregates,
	 including operations
	 that take functions
	 as arguments,
	 in multiple
	 programming
	 languages,
	 selecting the
	 most natural
	 idioms for
	 each language.
Program Representation                                                                            0.0/1.0			0.0/0.0
1.	Explain how programs                                                                      Familiarity         		None
	 that process
	 other programs
	 treat the other
	 programs as
	 their input
	 data.
2.	Describe an abstract                                                                      Usage               		None
	 syntax tree
	 for a small
	 language.
3.	Describe the benefits                                                                     Familiarity         		None
	 of having program
	 representations
	 other than
	 strings of
	 source code.
4.	Write a program                                                                           Usage               		None
	 to process
	 some representation
	 of code for
	 some purpose,
	 such as an
	 interpreter,
	 an expression
	 optimizer,
	 or a documentation
	 generator.
Runtime Systems                                                                                   0.0/0.0			0.0/0.0
1.	Compare the benefits                                                                      Familiarity         		None
	 of different
	 memory-management
	 schemes, using
	 concepts such
	 as fragmentation,
	 locality, and
	 memory overhead.
2.	Discuss benefits                                                                          Familiarity         		None
	 and limitations
	 of automatic
	 memory management.
3.	Explain the use                                                                           Familiarity         		None
	 of metadata
	 in run-time
	 representations
	 of objects
	 and activation
	 records, such
	 as class pointers,
	 array lengths,
	 return addresses,
	 and frame pointers.
4.	Discuss advantages,                                                                       Familiarity         		None
	 disadvantages,
	 and difficulties
	 of just-in-time
	 and dynamic
	 recompilation.
5.	Identify the services                                                                     Familiarity         		None
	 provided by
	 modern language
	 run-time systems.
Static Analysis                                                                                   0.0/0.0			0.0/0.0
1.	Define useful static                                                                      Usage               		None
	 analyses in
	 terms of a
	 conceptual
	 framework such
	 as dataflow
	 analysis.
2.	Explain why non-trivial                                                                   Familiarity         		None
	 sound static
	 analyses must
	 be approximate.
3.	Communicate why                                                                           Usage               		None
	 an analysis
	 is correct
	 (sound and
	 terminating).
4.	Distinguish may                                                                           Familiarity         		None
	 and must analyses.
5.	Explain why potential                                                                     Familiarity         		None
	 aliasing limits
	 sound program
	 analysis and
	 how alias analysis
	 can help.
6.	Use the results                                                                           Usage               		None
	 of a static
	 analysis for
	 program optimization
	 and/or partial
	 program correctness.
Syntax Analysis                                                                                   0.0/0.0			0.0/0.0
1.	Use formal grammars                                                                       Usage               		None
	 to specify
	 the syntax
	 of languages.
2.	Use declarative                                                                           Usage               		None
	 tools to generate
	 parsers and
	 scanners.
3.	Identify key issues                                                                       Familiarity         		None
	 in syntax definitions:
	 ambiguity,
	 associativity,
	 precedence.
Type Systems                                                                                      0.0/0.0			0.0/0.0
1.	Define a type system                                                                      Usage               		None
	 precisely and
	 compositionally.
2.	For various foundational                                                                  Familiarity         		None
	 type constructors,
	 identify the
	 values they
	 describe and
	 the invariants
	 they enforce.
3.	Precisely specify                                                                         Familiarity         		None
	 the invariants
	 preserved by
	 a sound type
	 system.
4.	Prove type safety                                                                         Usage               		None
	 for a simple
	 language in
	 terms of preservation
	 and progress
	 theorems.
5.	Implement a unification-based                                                             Usage               		None
	 type-inference
	 algorithm for
	 a simple language.
6.	Explain how static                                                                        Familiarity         		None
	 overloading
	 and associated
	 resolution
	 algorithms
	 influence the
	 dynamic behavior
	 of programs.

SDF- Software Development Fundamentals
Algorithms and Design                                                                             11.0/0.0			0.0/0.0
1.	Discuss the importance                                                                    Familiarity         		None
	 of algorithms
	 in the problem-solving
	 process.
2.	Discuss how a problem                                                                     Familiarity         		None
	 may be solved
	 by multiple
	 algorithms,
	 each with different
	 properties.
3.	Create algorithms                                                                         Usage               		None
	 for solving
	 simple problems.
4.	Use a programming                                                                         Usage               		None
	 language to
	 implement,
	 test, and debug
	 algorithms
	 for solving
	 simple problems.
5.	Implement, test,                                                                          Usage               		None
	 and debug simple
	 recursive functions
	 and procedures.
6.	Determine whether                                                                         Assessment          		None
	 a recursive
	 or iterative
	 solution is
	 most appropriate
	 for a problem.
7.	Implement a divide-and-conquer                                                            Usage               		None
	 algorithm for
	 solving a problem.
8.	Apply the techniques                                                                      Usage               		None
	 of decomposition
	 to break a
	 program into
	 smaller pieces.
9.	Identify the data                                                                         Usage               		None
	 components
	 and behaviors
	 of multiple
	 abstract data
	 types.
10.	Implement a coherent                                                                      Usage               		None
	 abstract data
	 type, with
	 loose coupling
	 between components
	 and behaviors.
11.	Identify the relative                                                                     Assessment          		None
	 strengths and
	 weaknesses
	 among multiple
	 designs or
	 implementations
	 for a problem.
Development Methods                                                                               10.0/0.0			0.0/0.0
1.	Trace the execution                                                                       Assessment          		None
	 of a variety
	 of code segments
	 and write summaries
	 of their computations.
2.	Explain why the                                                                           Familiarity         		None
	 creation of
	 correct program
	 components
	 is important
	 in the production
	 of high-quality
	 software.
3.	Identify common                                                                           Usage               		None
	 coding errors
	 that lead to
	 insecure programs
	 (eg, buffer
	 overflows,
	 memory leaks,
	 malicious code)
	 and apply strategies
	 for avoiding
	 such errors.
4.	Conduct a personal                                                                        Usage               		None
	 code review
	 (focused on
	 common coding
	 errors) on
	 a program component
	 using a provided
	 checklist.
5.	Contribute to a                                                                           Usage               		None
	 small-team
	 code review
	 focused on
	 component correctness.
6.	Describe how a contract                                                                   Familiarity         		None
	 can be used
	 to specify
	 the behavior
	 of a program
	 component.
7.	Refactor a program                                                                        Usage               		None
	 by identifying
	 opportunities
	 to apply procedural
	 abstraction.
8.	Apply a variety                                                                           Usage               		None
	 of strategies
	 to the testing
	 and debugging
	 of simple programs.
9.	Construct, execute                                                                        Usage               		None
	 and debug programs
	 using a modern
	 IDE and associated
	 tools such
	 as unit testing
	 tools and visual
	 debuggers.
10.	Construct and debug                                                                       Usage               		None
	 programs using
	 the standard
	 libraries available
	 with a chosen
	 programming
	 language.
11.	Analyze the extent                                                                        Assessment          		None
	 to which another
	 programmer’s
	 code meets
	 documentation
	 and programming
	 style standards.
12.	Apply consistent                                                                          Usage               		None
	 documentation
	 and program
	 style standards
	 that contribute
	 to the readability
	 and maintainability
	 of software.
Fundamental Data Structures                                                                       12.0/0.0			0.0/0.0
1.	Discuss the appropriate                                                                   Familiarity         		None
	 use of built-in
	 data structures.
2.	Describe common                                                                           Familiarity         		None
	 applications
	 for each  of
	 the following
	 data structures:
	 stack, queue,
	 priority queue,
	 set, and map.
	 
3.	Write programs that                                                                       Usage               		None
	 use each of
	 the following
	 data structures:
	 arrays, records/structs,
	 strings, linked
	 lists, stacks,
	 queues, sets,
	 and maps.
4.	Compare alternative                                                                       Assessment          		None
	 implementations
	 of data structures
	 with respect
	 to performance.
5.	Describe how references                                                                   Familiarity         		None
	 allow for objects
	 to be accessed
	 in multiple
	 ways.
6.	Compare and contrast                                                                      Assessment          		None
	 the costs and
	 benefits of
	 dynamic and
	 static data
	 structure implementations.
7.	Choose the appropriate                                                                    Assessment          		None
	 data structure
	 for modeling
	 a given problem.
Fundamental Programming Concepts                                                                  10.0/0.0			0.0/0.0
1.	Analyze and explain                                                                       Assessment          		None
	 the behavior
	 of simple programs
	 involving the
	 fundamental
	 programming
	 constructs
	 variables,
	 expressions,
	 assignments,
	 I/O, control
	 constructs,
	 functions,
	 parameter passing,
	 and recursion.
	 
2.	Identify and describe                                                                     Familiarity         		None
	 uses of primitive
	 data types.
3.	Write programs that                                                                       Usage               		None
	 use primitive
	 data types.
4.	Modify and expand                                                                         Usage               		None
	 short programs
	 that use standard
	 conditional
	 and iterative
	 control structures
	 and functions.
5.	Design, implement,                                                                        Usage               		None
	 test, and debug
	 a program that
	 uses each of
	 the following
	 fundamental
	 programming
	 constructs:
	 basic computation,
	 simple I/O,
	 standard conditional
	 and iterative
	 structures,
	 the definition
	 of functions,
	 and parameter
	 passing.
6.	Write a program                                                                           Usage               		None
	 that uses file
	 I/O to provide
	 persistence
	 across multiple
	 executions.
7.	Choose appropriate                                                                        Assessment          		None
	 conditional
	 and iteration
	 constructs
	 for a given
	 programming
	 task.
8.	Describe the concept                                                                      Familiarity         		None
	 of recursion
	 and give examples
	 of its use.
9.	Identify the base                                                                         Assessment          		None
	 case and the
	 general case
	 of a recursively-defined
	 problem.

SE- Software Engineering
Formal Methods                                                                                    0.0/0.0			0.0/0.0
1.	Describe the role                                                                         Familiarity         		None
	 formal specification
	 and analysis
	 techniques
	 can play in
	 the development
	 of complex
	 software and
	 compare their
	 use as validation
	 and verification
	 techniques
	 with testing.
2.	Apply formal specification                                                                Usage               		None
	 and analysis
	 techniques
	 to software
	 designs and
	 programs with
	 low complexity.
3.	Explain the potential                                                                     Familiarity         		None
	 benefits and
	 drawbacks of
	 using formal
	 specification
	 languages.
4.	Create and evaluate                                                                       Usage               		None
	 program assertions
	 for a variety
	 of behaviors
	 ranging from
	 simple through
	 complex.
5.	Using a common formal                                                                     Usage               		None
	 specification
	 language, formulate
	 the specification
	 of a simple
	 software system
	 and derive
	 examples of
	 test cases
	 from the specification.
Requirements Engineering                                                                          1.0/3.0			0.0/0.0
1.	List the key components                                                                   Familiarity         		None
	 of a use case
	 or similar
	 description
	 of some behavior
	 that is required
	 for a system.
2.	Describe how the                                                                          Familiarity         		None
	 requirements
	 engineering
	 process supports
	 the elicitation
	 and validation
	 of behavioral
	 requirements.
3.	Interpret a given                                                                         Familiarity         		None
	 requirements
	 model for a
	 simple software
	 system.
4.	Describe the fundamental                                                                  Familiarity         		None
	 challenges
	 of and common
	 techniques
	 used for requirements
	 elicitation.
5.	List the key components                                                                   Familiarity         		None
	 of a data model
	 (eg, class
	 diagrams or
	 ER diagrams).
6.	Identify both functional                                                                  Usage               		None
	 and non-functional
	 requirements
	 in a given
	 requirements
	 specification
	 for a software
	 system.
7.	Conduct a review                                                                          Usage               		None
	 of a set of
	 software requirements
	 to determine
	 the quality
	 of the requirements
	 with respect
	 to the characteristics
	 of good requirements.
8.	Apply key elements                                                                        Usage               		None
	 and common
	 methods for
	 elicitation
	 and analysis
	 to produce
	 a set of software
	 requirements
	 for a medium-sized
	 software system.
9.	Compare the plan-driven                                                                   Familiarity         		None
	 and agile approaches
	 to requirements
	 specification
	 and validation
	 and describe
	 the benefits
	 and risks associated
	 with each.
10.	Use a common, non-formal                                                                  Usage               		None
	 method to model
	 and specify
	 the requirements
	 for a medium-size
	 software system.
11.	Translate into natural                                                                    Usage               		None
	 language a
	 software requirements
	 specification
	 (eg, a software
	 component contract)
	 written in
	 a formal specification
	 language.
12.	Create a prototype                                                                        Usage               		None
	 of a software
	 system to mitigate
	 risk in requirements.
13.	Differentiate between                                                                     Familiarity         		None
	 forward and
	 backward tracing
	 and explain
	 their roles
	 in the requirements
	 validation
	 process.
Software Construction                                                                             0.0/2.0			0.0/0.0
1.	Describe techniques,                                                                      Familiarity         		None
	 coding idioms
	 and mechanisms
	 for implementing
	 designs to
	 achieve desired
	 properties
	 such as reliability,
	 efficiency,
	 and robustness.
2.	Build robust code                                                                         Usage               		None
	 using exception
	 handling mechanisms.
3.	Describe secure                                                                           Familiarity         		None
	 coding and
	 defensive coding
	 practices.
4.	Select and use a                                                                          Usage               		None
	 defined coding
	 standard in
	 a small software
	 project.
5.	Compare and contrast                                                                      Familiarity         		None
	 integration
	 strategies
	 including top-down,
	 bottom-up,
	 and sandwich
	 integration.
6.	Describe the process                                                                      Familiarity         		None
	 of analyzing
	 and implementing
	 changes to
	 code base developed
	 for a specific
	 project.
7.	Describe the process                                                                      Familiarity         		None
	 of analyzing
	 and implementing
	 changes to
	 a large existing
	 code base.
8.	Rewrite a simple                                                                          Usage               		None
	 program to
	 remove common
	 vulnerabilities,
	 such as buffer
	 overflows,
	 integer overflows
	 and race conditions.
9.	Write a software                                                                          Usage               		None
	 component that
	 performs some
	 non-trivial
	 task and is
	 resilient to
	 input and run-time
	 errors.
Software Design                                                                                   3.0/5.0			0.0/0.0
1.	Articulate design                                                                         Familiarity         		None
	 principles
	 including separation
	 of concerns,
	 information
	 hiding, coupling
	 and cohesion,
	 and encapsulation.
2.	Use a design paradigm                                                                     Usage               		None
	 to design a
	 simple software
	 system, and
	 explain how
	 system design
	 principles
	 have been applied
	 in this design.
3.	Construct models                                                                          Usage               		None
	 of the design
	 of a simple
	 software system
	 that are appropriate
	 for the paradigm
	 used to design
	 it.
4.	Within the context                                                                        Familiarity         		None
	 of a single
	 design paradigm,
	 describe one
	 or more design
	 patterns that
	 could be applicable
	 to the design
	 of a simple
	 software system.
5.	For a simple system                                                                       Usage               		None
	 suitable for
	 a given scenario,
	 discuss and
	 select an appropriate
	 design paradigm.
6.	Create appropriate                                                                        Usage               		None
	 models for
	 the structure
	 and behavior
	 of software
	 products from
	 their requirements
	 specifications.
7.	Explain the relationships                                                                 Assessment          		None
	 between the
	 requirements
	 for a software
	 product and
	 its design,
	 using appropriate
	 models.
8.	For the design of                                                                         Familiarity         		None
	 a simple software
	 system within
	 the context
	 of a single
	 design paradigm,
	 describe the
	 software architecture
	 of that system.
9.	Given a high-level                                                                        Familiarity         		None
	 design, identify
	 the software
	 architecture
	 by differentiating
	 among common
	 software architectures
	 such as 3-tier,
	 pipe-and-filter,
	 and client-server.
10.	Investigate the                                                                           Assessment          		None
	 impact of software
	 architectures
	 selection on
	 the design
	 of a simple
	 system.
11.	Apply simple examples                                                                     Usage               		None
	 of patterns
	 in a software
	 design.
12.	Describe a form                                                                           Familiarity         		None
	 of refactoring
	 and discuss
	 when it may
	 be applicable.
13.	Select suitable                                                                           Usage               		None
	 components
	 for use in
	 the design
	 of a software
	 product.
14.	Explain how suitable                                                                      Familiarity         		None
	 components
	 might need
	 to be adapted
	 for use in
	 the design
	 of a software
	 product.
15.	Design a contract                                                                         Usage               		None
	 for a typical
	 small software
	 component for
	 use in a given
	 system.
16.	Discuss and select                                                                        Usage               		None
	 appropriate
	 software architecture
	 for a simple
	 system suitable
	 for a given
	 scenario.
17.	Apply models for                                                                          Usage               		None
	 internal and
	 external qualities
	 in designing
	 software components
	 to achieve
	 an acceptable
	 tradeoff between
	 conflicting
	 quality aspects.
18.	Analyze a software                                                                        Assessment          		None
	 design from
	 the perspective
	 of a significant
	 internal quality
	 attribute.
19.	Analyze a software                                                                        Assessment          		None
	 design from
	 the perspective
	 of a significant
	 external quality
	 attribute.
20.	Explain the role                                                                          Familiarity         		None
	 of objects
	 in middleware
	 systems and
	 the relationship
	 with components.
21.	Apply component-oriented                                                                  Usage               		None
	 approaches
	 to the design
	 of a range
	 of software,
	 such as using
	 components
	 for concurrency
	 and transactions,
	 for reliable
	 communication
	 services, for
	 database interaction
	 including services
	 for remote
	 query and database
	 management,
	 or for secure
	 communication
	 and access.
22.	Refactor an existing                                                                      Usage               		None
	 software implementation
	 to improve
	 some aspect
	 of its design.
23.	State and apply                                                                           Familiarity         		None
	 the principles
	 of least privilege
	 and fail-safe
	 defaults.
Software Evolution                                                                                0.0/2.0			0.0/0.0
1.	Identify the principal                                                                    Familiarity         		None
	 issues associated
	 with software
	 evolution and
	 explain their
	 impact on the
	 software lifecycle.
2.	Estimate the impact                                                                       Usage               		None
	 of a change
	 request to
	 an existing
	 product of
	 medium size.
3.	Use refactoring                                                                           Usage               		None
	 in the process
	 of modifying
	 a software
	 component.
4.	Discuss the challenges                                                                    Familiarity         		None
	 of evolving
	 systems in
	 a changing
	 environment.
5.	Outline the process                                                                       Familiarity         		None
	 of regression
	 testing and
	 its role in
	 release management.
6.	Discuss the advantages                                                                    Familiarity         		None
	 and disadvantages
	 of different
	 types of software
	 reuse.
Software Processes                                                                                2.0/1.0			0.0/0.0
1.	Describe how software                                                                     Familiarity         		None
	 can interact
	 with and participate
	 in various
	 systems including
	 information
	 management,
	 embedded, process
	 control, and
	 communications
	 systems.
2.	Describe the relative                                                                     Familiarity         		None
	 advantages
	 and disadvantages
	 among  several
	  major process
	 models (eg,
	 waterfall,
	 iterative,
	 and agile).
3.	Describe the different                                                                    Familiarity         		None
	 practices that
	 are key components
	 of various
	 process models.
4.	Differentiate among                                                                       Familiarity         		None
	 the phases
	 of software
	 development.
5.	Describe how programming                                                                  Familiarity         		None
	 in the large
	 differs from
	 individual
	 efforts with
	 respect to
	 understanding
	 a large code
	 base, code
	 reading, understanding
	 builds, and
	 understanding
	 context of
	 changes.
6.	Explain the concept                                                                       Familiarity         		None
	 of a software
	 lifecycle and
	 provide an
	 example, illustrating
	 its phases
	 including the
	 deliverables
	 that are produced.
7.	Compare several                                                                           Usage               		None
	 common process
	 models with
	 respect to
	 their value
	 for development
	 of particular
	 classes of
	 software systems
	 taking into
	 account issues
	 such as requirement
	 stability,
	 size, and non-functional
	 characteristics.
8.	Define software                                                                           Familiarity         		None
	 quality and
	 describe the
	 role of quality
	 assurance activities
	 in the software
	 process.
9.	Describe the intent                                                                       Familiarity         		None
	 and fundamental
	 similarities
	 among process
	 improvement
	 approaches.
10.	Compare several                                                                           Assessment          		None
	 process improvement
	 models such
	 as CMM, CMMI,
	 CQI, Plan-Do-Check-Act,
	 or ISO9000.
11.	Assess a development                                                                      Usage               		None
	 effort and
	 recommend potential
	 changes by
	 participating
	 in process
	 improvement
	 (using a model
	 such as PSP)
	 or engaging
	 in a project
	 retrospective.
12.	Explain the role                                                                          Familiarity         		None
	 of process
	 maturity models
	 in process
	 improvement.
13.	Describe several                                                                          Familiarity         		None
	 process metrics
	 for assessing
	 and controlling
	 a project.
14.	Use project metrics                                                                       Usage               		None
	 to describe
	 the current
	 state of a
	 project.
Software Project Management                                                                       0.0/2.0			0.0/0.0
1.	Discuss common behaviors                                                                  Familiarity         		None
	 that contribute
	 to the effective
	 functioning
	 of a team.
2.	Create and follow                                                                         Usage               		None
	 an agenda for
	 a team meeting.
3.	Identify and justify                                                                      Usage               		None
	 necessary roles
	 in a software
	 development
	 team.
4.	Understand the sources,                                                                   Usage               		None
	 hazards, and
	 potential benefits
	 of team conflict.
5.	Apply a conflict                                                                          Usage               		None
	 resolution
	 strategy in
	 a team setting.
6.	Use an ad hoc method                                                                      Usage               		None
	 to estimate
	 software development
	 effort (eg,
	 time) and compare
	 to actual effort
	 required.
7.	List several examples                                                                     Familiarity         		None
	 of software
	 risks.
8.	Describe the impact                                                                       Familiarity         		None
	 of risk in
	 a software
	 development
	 lifecycle.
9.	Describe different                                                                        Familiarity         		None
	 categories
	 of risk in
	 software systems.
10.	Demonstrate through                                                                       Usage               		None
	 involvement
	 in a team project
	 the central
	 elements of
	 team building
	 and team management.
11.	Describe how the                                                                          Familiarity         		None
	 choice of process
	 model affects
	 team organizational
	 structures
	 and decision-making
	 processes.
12.	Create a team by                                                                          Usage               		None
	 identifying
	 appropriate
	 roles and assigning
	 roles to team
	 members.
13.	Assess and provide                                                                        Usage               		None
	 feedback to
	 teams and individuals
	 on their performance
	 in a team setting.
14.	Using a particular                                                                        Familiarity         		None
	 software process,
	 describe the
	 aspects of
	 a project that
	 need to be
	 planned and
	 monitored,
	 (eg, estimates
	 of size and
	 effort, a schedule,
	 resource allocation,
	 configuration
	 control, change
	 management,
	 and project
	 risk identification
	 and management).
15.	Track the progress                                                                        Usage               		None
	 of some stage
	 in a project
	 using appropriate
	 project metrics.
16.	Compare simple software                                                                   Usage               		None
	 size and cost
	 estimation
	 techniques.
17.	Use a project management                                                                  Usage               		None
	 tool to assist
	 in the assignment
	 and tracking
	 of tasks in
	 a software
	 development
	 project.
18.	Describe the impact                                                                       Assessment          		None
	 of risk tolerance
	 on the software
	 development
	 process.
19.	Identify risks and                                                                        Familiarity         		None
	 describe approaches
	 to managing
	 risk (avoidance,
	 acceptance,
	 transference,
	 mitigation),
	 and characterize
	 the strengths
	 and shortcomings
	 of each.
20.	Explain how risk                                                                          Usage               		None
	 affects decisions
	 in the software
	 development
	 process.
21.	Identify security                                                                         Usage               		None
	 risks for a
	 software system.
22.	Demonstrate a systematic                                                                  Usage               		None
	 approach to
	 the task of
	 identifying
	 hazards and
	 risks in a
	 particular
	 situation.
23.	Apply the basic                                                                           Usage               		None
	 principles
	 of risk management
	 in a variety
	 of simple scenarios
	 including a
	 security situation.
24.	Conduct a cost/benefit                                                                    Usage               		None
	 analysis for
	 a risk mitigation
	 approach.
25.	Identify and analyze                                                                      Usage               		None
	 some of the
	 risks for an
	 entire system
	 that arise
	 from aspects
	 other than
	 the software.
Software Reliability                                                                              0.0/1.0			0.0/0.0
1.	Explain the problems                                                                      Familiarity         		None
	 that exist
	 in achieving
	 very high levels
	 of reliability.
2.	Describe how software                                                                     Familiarity         		None
	 reliability
	 contributes
	 to system reliability.
3.	List approaches                                                                           Familiarity         		None
	 to minimizing
	 faults that
	 can be applied
	 at each stage
	 of the software
	 lifecycle.
4.	Compare the characteristics                                                               Familiarity         		None
	 of three different
	 reliability
	 modeling approaches.
5.	Demonstrate the                                                                           Usage               		None
	 ability to
	 apply multiple
	 methods to
	 develop reliability
	 estimates for
	 a software
	 system.
6.	Identify methods                                                                          Usage               		None
	 that will lead
	 to the realization
	 of a software
	 architecture
	 that achieves
	 a specified
	 level of reliability.
7.	Identify ways to                                                                          Usage               		None
	 apply redundancy
	 to achieve
	 fault tolerance
	 for a medium-sized
	 application.
Software Verification Validation                                                                  0.0/3.0			0.0/0.0
1.	Distinguish between                                                                       Familiarity         		None
	 program validation
	 and verification.
2.	Describe the role                                                                         Familiarity         		None
	 that tools
	 can play in
	 the validation
	 of software.
3.	Undertake, as part                                                                        Usage               		None
	 of a team activity,
	 an inspection
	 of a medium-size
	 code segment.
4.	Describe and distinguish                                                                  Familiarity         		None
	 among the different
	 types and levels
	 of testing
	 (unit, integration,
	 systems, and
	 acceptance).
5.	Describe techniques                                                                       Familiarity         		None
	 for identifying
	 significant
	 test cases
	 for integration,
	 regression
	 and system
	 testing.
6.	Create and document                                                                       Usage               		None
	 a set of tests
	 for a medium-size
	 code segment.
7.	Describe how to                                                                           Familiarity         		None
	 select good
	 regression
	 tests and automate
	 them.
8.	Use a defect tracking                                                                     Usage               		None
	 tool to manage
	 software defects
	 in a small
	 software project.
9.	Discuss the limitations                                                                   Familiarity         		None
	 of testing
	 in a particular
	 domain.
10.	Evaluate a test                                                                           Usage               		None
	 suite for a
	 medium-size
	 code segment.
11.	Compare static and                                                                        Familiarity         		None
	 dynamic approaches
	 to verification.
12.	Identify the fundamental                                                                  Familiarity         		None
	 principles
	 of test-driven
	 development
	 methods and
	 explain the
	 role of automated
	 testing in
	 these methods.
13.	Discuss the issues                                                                        Usage               		None
	 involving the
	 testing of
	 object-oriented
	 software.
14.	Describe techniques                                                                       Familiarity         		None
	 for the verification
	 and validation
	 of non-code
	 artifacts.
15.	Describe approaches                                                                       Familiarity         		None
	 for fault estimation.
16.	Estimate the number                                                                       Usage               		None
	 of faults in
	 a small software
	 application
	 based on fault
	 density and
	 fault seeding.
17.	Conduct an inspection                                                                     Usage               		None
	 or review of
	 software source
	 code for a
	 small or medium
	 sized software
	 project.
Tools and Environments                                                                            0.0/2.0			0.0/0.0
1.	Describe the difference                                                                   Familiarity         		None
	 between centralized
	 and distributed
	 software configuration
	 management.
2.	Describe how version                                                                      Familiarity         		None
	 control can
	 be used to
	 help manage
	 software release
	 management.
3.	Identify configuration                                                                    Usage               		None
	 items and use
	 a source code
	 control tool
	 in a small
	 team-based
	 project.
4.	Describe how available                                                                    Familiarity         		None
	 static and
	 dynamic test
	 tools can be
	 integrated
	 into the software
	 development
	 environment.
5.	Describe the issues                                                                       Familiarity         		None
	 that are important
	 in selecting
	 a set of tools
	 for the development
	 of a particular
	 software system,
	 including tools
	 for requirements
	 tracking, design
	 modeling, implementation,
	 build automation,
	 and testing.
6.	Demonstrate the                                                                           Usage               		None
	 capability
	 to use software
	 tools in support
	 of the development
	 of a software
	 product of
	 medium size.

SF- Systems Fundamentals
Computational Paradigms                                                                           3.0/0.0			0.0/0.0
1.	List commonly encountered                                                                 Familiarity         		None
	 patterns of
	 how computations
	 are organized.
2.	Describe the basic                                                                        Familiarity         		None
	 building blocks
	 of computers
	 and their role
	 in the historical
	 development
	 of computer
	 architecture.
3.	Articulate the differences                                                                Familiarity         		None
	 between single
	 thread vs multiple
	 thread, single
	 server vs multiple
	 server models,
	 motivated by
	 real world
	 examples (eg,
	 cooking recipes,
	 lines for multiple
	 teller machines
	 and couples
	 shopping for
	 food).
4.	Articulate the concept                                                                    Familiarity         		None
	 of strong vs
	 weak scaling,
	 ie, how performance
	 is affected
	 by scale of
	 problem vs
	 scale of resources
	 to solve the
	 problem This
	 can be motivated
	 by the simple,
	 real-world
	 examples.
5.	Design a simple                                                                           Usage               		None
	 logic circuit
	 using the fundamental
	 building blocks
	 of logic design.
6.	Use tools for capture,                                                                    Usage               		None
	 synthesis,
	 and simulation
	 to evaluate
	 a logic design.
7.	Write a simple sequential                                                                 Usage               		None
	 problem and
	 a simple parallel
	 version of
	 the same program.
8.	Evaluate performance                                                                      Assessment          		None
	 of simple sequential
	 and parallel
	 versions of
	 a program with
	 different problem
	 sizes, and
	 be able to
	 describe the
	 speed-ups achieved.
Cross-Layer Communications                                                                        3.0/0.0			0.0/0.0
1.	Describe how computing                                                                    Familiarity         		None
	 systems are
	 constructed
	 of layers upon
	 layers, based
	 on separation
	 of concerns,
	 with well-defined
	 interfaces,
	 hiding details
	 of low layers
	 from the higher
	 layers.
2.	Describe that hardware,                                                                   Familiarity         		None
	 VM, OS, application
	 are additional
	 layers of interpretation/processing.
3.	Describe the mechanisms                                                                   Familiarity         		None
	 of how errors
	 are detected,
	 signaled back,
	 and handled
	 through the
	 layers.
4.	Construct a simple                                                                        Usage               		None
	 program using
	 methods of
	 layering, error
	 detection and
	 recovery, and
	 reflection
	 of error status
	 across layers.
5.	Find bugs in a layered                                                                    Usage               		None
	 program by
	 using tools
	 for program
	 tracing, single
	 stepping, and
	 debugging.
Evaluation                                                                                        3.0/0.0			0.0/0.0
1.	Explain how the                                                                           Familiarity         		None
	 components
	 of system architecture
	 contribute
	 to improving
	 its performance.
2.	Describe Amdahl’s                                                                         Familiarity         		None
	 law and discuss
	 its limitations.
3.	Design and conduct                                                                        Usage               		None
	 a performance-oriented
	 experiment.
4.	Use software tools                                                                        Assessment          		None
	 to profile
	 and measure
	 program performance.
Parallelism                                                                                       1.0/0.0			0.0/0.0
1.	For a given program,                                                                      Familiarity         		None
	 distinguish
	 between its
	 sequential
	 and parallel
	 execution,
	 and the performance
	 implications
	 thereof.
2.	Demonstrate on an                                                                         Familiarity         		None
	 execution time
	 line that parallelism
	 events and
	 operations
	 can take place
	 simultaneously
	 (ie, at the
	 same time)
	 Explain how
	 work can be
	 performed in
	 less elapsed
	 time if this
	 can be exploited.
3.	Explain other uses                                                                        Familiarity         		None
	 of parallelism,
	 such as for
	 reliability/redundancy
	 of execution.
4.	Define the differences                                                                    Familiarity         		None
	 between the
	 concepts of
	 Instruction
	 Parallelism,
	 Data Parallelism,
	 Thread Parallelism/Multitasking,
	 Task/Request
	 Parallelism.
5.	Write more than                                                                           Usage               		None
	 one parallel
	 program (eg,
	 one simple
	 parallel program
	 in more than
	 one parallel
	 programming
	 paradigm; a
	 simple parallel
	 program that
	 manages shared
	 resources through
	 synchronization
	 primitives;
	 a simple parallel
	 program that
	 performs simultaneous
	 operation on
	 partitioned
	 data through
	 task parallel
	 (eg, parallel
	 search terms;
	 a simple parallel
	 program that
	 performs step-by-step
	 pipeline processing
	 through message
	 passing).
6.	Use performance                                                                           Assessment          		None
	 tools to measure
	 speed-up achieved
	 by parallel
	 programs in
	 terms of both
	 problem size
	 and number
	 of resources.
Proximity                                                                                         0.0/3.0			0.0/0.0
1.	Explain the importance                                                                    Familiarity         		None
	 of locality
	 in determining
	 performance.
2.	Describe why things                                                                       Familiarity         		None
	 that are close
	 in space take
	 less time to
	 access.
3.	Calculate average                                                                         Assessment          		None
	 memory access
	 time and describe
	 the tradeoffs
	 in memory hierarchy
	 performance
	 in terms of
	 capacity, miss/hit
	 rate, and access
	 time.
Quantitative Evaluation                                                                           0.0/0.0			0.0/0.0
1.	Explain the circumstances                                                                 Familiarity         		None
	 in which a
	 given figure
	 of system performance
	 metric is useful.
2.	Explain the inadequacies                                                                  Familiarity         		None
	 of benchmarks
	 as a measure
	 of system performance.
3.	Use limit studies                                                                         Usage               		None
	 or simple calculations
	 to produce
	 order-of-magnitude
	 estimates for
	 a given performance
	 metric in a
	 given context.
4.	Conduct a performance                                                                     Assessment          		None
	 experiment
	 on a layered
	 system to determine
	 the effect
	 of a system
	 parameter on
	 figure of system
	 performance.
Reliability through Redundancy                                                                    0.0/2.0			0.0/0.0
1.	Explain the distinction                                                                   Familiarity         		None
	 between program
	 errors, system
	 errors, and
	 hardware faults
	 (eg, bad memory)
	 and exceptions
	 (eg, attempt
	 to divide by
	 zero).
2.	Articulate the distinction                                                                Familiarity         		None
	 between detecting,
	 handling, and
	 recovering
	 from faults,
	 and the methods
	 for their implementation.
3.	Describe the role                                                                         Familiarity         		None
	 of error correcting
	 codes in providing
	 error checking
	 and correction
	 techniques
	 in memories,
	 storage, and
	 networks.
4.	Apply simple algorithms                                                                   Usage               		None
	 for exploiting
	 redundant information
	 for the purposes
	 of data correction.
5.	Compare different                                                                         Assessment          		None
	 error detection
	 and correction
	 methods for
	 their data
	 overhead, implementation
	 complexity,
	 and relative
	 execution time
	 for encoding,
	 detecting,
	 and correcting
	 errors.
Resource Allocation and Scheduling                                                                0.0/2.0			0.0/0.0
1.	Define how finite                                                                         Familiarity         		None
	 computer resources
	 (eg, processor
	 share, memory,
	  storage and
	 network bandwidth)
	 are managed
	 by their careful
	 allocation
	 to existing
	 entities.
2.	Describe the scheduling                                                                   Familiarity         		None
	 algorithms
	 by which resources
	 are allocated
	 to competing
	 entities, and
	 the figures
	 of merit by
	 which these
	 algorithms
	 are evaluated,
	 such as fairness.
3.	Implement simple                                                                          Usage               		None
	 schedule algorithms.
4.	Use figures of merit                                                                      Assessment          		None
	 of alternative
	 scheduler implementations.
State and State Machines                                                                          6.0/0.0			0.0/0.0
1.	Describe computations                                                                     Familiarity         		None
	 as a system
	 characyterized
	 by a known
	 set of configurations
	 with transitions
	 from one unique
	 configuration
	 (state) to
	 another (state).
2.	Describe the distinction                                                                  Familiarity         		None
	 between systems
	 whose output
	 is only a function
	 of their input
	 (Combinational)
	 and those with
	 memory/history
	 (Sequential).
3.	Describe a computer                                                                       Familiarity         		None
	 as a state
	 machine that
	 interprets
	 machine instructions.
4.	Explain how a program                                                                     Familiarity         		None
	 or network
	 protocol can
	 also be expressed
	 as a state
	 machine, and
	 that alternative
	 representations
	 for the same
	 computation
	 can exist.
5.	Develop state machine                                                                     Usage               		None
	 descriptions
	 for simple
	 problem statement
	 solutions (eg,
	 traffic light
	 sequencing,
	 pattern recognizers).
6.	Derive time-series                                                                        Assessment          		None
	 behavior of
	 a state machine
	 from its state
	 machine representation.
Virtualization and Isolation                                                                      0.0/2.0			0.0/0.0
1.	Explain why it is                                                                         Familiarity         		None
	 important to
	 isolate and
	 protect the
	 execution of
	 individual
	 programs and
	 environments
	 that share
	 common underlying
	 resources.
2.	Describe how the                                                                          Familiarity         		None
	 concept of
	 indirection
	 can create
	 the illusion
	 of a dedicated
	 machine and
	 its resources
	 even when physically
	 shared among
	 multiple programs
	 and environments.
3.	Measure the performance                                                                   Assessment          		None
	 of two application
	 instances running
	 on separate
	 virtual machines,
	 and determine
	 the effect
	 of performance
	 isolation.

SP- Social Issues and Professional Practice
Analytical Tools                                                                                  2.0/0.0			0.0/0.0
1.	Evaluate stakeholder                                                                      Assessment          		None
	 positions in
	 a given situation.
2.	Analyze basic logical                                                                     Assessment          		None
	 fallacies in
	 an argument.
3.	Analyze an argument                                                                       Assessment          		None
	 to identify
	 premises and
	 conclusion.
4.	Illustrate the use                                                                        Usage               		None
	 of example
	 and analogy
	 in ethical
	 argument.
5.	Evaluate ethical/social                                                                   Assessment          		None
	 tradeoffs in
	 technical decisions.
Economies of Computing                                                                            0.0/0.0			0.0/0.0
1.	Summarize the rationale                                                                   Familiarity         		None
	 for antimonopoly
	 efforts.
2.	Identify several                                                                          Familiarity         		None
	 ways in which
	 the information
	 technology
	 industry is
	 affected by
	 shortages in
	 the labor supply.
3.	Identify the evolution                                                                    Familiarity         		None
	 of pricing
	 strategies
	 for computing
	 goods and services.
4.	Discuss the benefits,                                                                     Familiarity         		None
	 the drawbacks
	 and the implications
	 of off-shoring
	 and outsourcing.
5.	Investigate and                                                                           Usage               		None
	 defend ways
	 to address
	 limitations
	 on access to
	 computing.
6.	Describe the economic                                                                     Familiarity         		None
	 benefits of
	 network effects.
History                                                                                           0.0/0.0			0.0/0.0
1.	Identify significant                                                                      Familiarity         		None
	 continuing
	 trends in the
	 history of
	 the computing
	 field.
2.	Identify the contributions                                                                Familiarity         		None
	 of several
	 pioneers in
	 the computing
	 field.
3.	Discuss the historical                                                                    Familiarity         		None
	 context for
	 several programming
	 language paradigms.
4.	Compare daily life                                                                        Assessment          		None
	 before and
	 after the advent
	 of personal
	 computers and
	 the Internet.
Intellectual Property                                                                             2.0/0.0			0.0/0.0
1.	Discuss the philosophical                                                                 Familiarity         		None
	 bases of intellectual
	 property.
2.	Discuss the rationale                                                                     Familiarity         		None
	 for the legal
	 protection
	 of intellectual
	 property.
3.	Describe legislation                                                                      Familiarity         		None
	 aimed at digital
	 copyright infringements.
4.	Critique legislation                                                                      Assessment          		None
	 aimed at digital
	 copyright infringements.
5.	Identify contemporary                                                                     Familiarity         		None
	 examples of
	 intangible
	 digital intellectual
	 property.
6.	Justify uses of                                                                           Assessment          		None
	 copyrighted
	 materials.
7.	Evaluate the ethical                                                                      Assessment          		None
	 issues inherent
	 in various
	 plagiarism
	 detection mechanisms.
8.	Interpret the intent                                                                      Familiarity         		None
	 and implementation
	 of software
	 licensing.
9.	Discuss the issues                                                                        Familiarity         		None
	 involved in
	 securing software
	 patents.
10.	Characterize and                                                                          Assessment          		None
	 contrast the
	 concepts of
	 copyright,
	 patenting and
	 trademarks.
11.	Identify the goals                                                                        Familiarity         		None
	 of the open
	 source movement.
12.	Identify the global                                                                       Familiarity         		None
	 nature of software
	 piracy.
Privacy and Civil Liberties                                                                       2.0/0.0			0.0/0.0
1.	Discuss the philosophical                                                                 Familiarity         		None
	 basis for the
	 legal protection
	 of personal
	 privacy.
2.	Evaluate solutions                                                                        Assessment          		None
	 to privacy
	 threats in
	 transactional
	 databases and
	 data warehouses.
3.	Describe the role                                                                         Familiarity         		None
	 of data collection
	 in the implementation
	 of pervasive
	 surveillance
	 systems (e.g.,
	 RFID, face
	 recognition,
	 toll collection,
	 mobile computing).
	 
4.	Describe the ramifications                                                                Familiarity         		None
	 of differential
	 privacy. 
5.	Investigate the                                                                           Usage               		None
	 impact of technological
	 solutions to
	 privacy problems.
6.	Critique the intent,                                                                      Assessment          		None
	 potential value
	 and implementation
	 of various
	 forms of privacy
	 legislation.
7.	Identify strategies                                                                       Familiarity         		None
	 to enable appropriate
	 freedom of
	 expression.
Professional Communication                                                                        1.0/0.0			0.0/0.0
1.	Write clear, concise,                                                                     Usage               		None
	 and accurate
	 technical documents
	 following well-defined
	 standards for
	 format and
	 for including
	 appropriate
	 tables, figures,
	 and references.
2.	Evaluate written                                                                          Assessment          		None
	 technical documentation
	 to detect problems
	 of various
	 kinds.
3.	Develop and deliver                                                                       Assessment          		None
	 a good quality
	 formal presentation.
4.	Plan interactions                                                                         Usage               		None
	 (eg virtual,
	 face-to-face,
	 shared documents)
	 with others
	 in which they
	 are able to
	 get their point
	 across, and
	 are also able
	 to listen carefully
	 and appreciate
	 the points
	 of others,
	 even when they
	 disagree, and
	 are able to
	 convey to others
	 that they have
	 heard.
5.	Describe the strengths                                                                    Familiarity         		None
	 and weaknesses
	 of various
	 forms of communication
	 (eg virtual,
	 face-to-face,
	 shared documents).
6.	Examine appropriate                                                                       Usage               		None
	 measures used
	 to communicate
	 with stakeholders
	 involved in
	 a project.
7.	Compare and contrast                                                                      Assessment          		None
	 various collaboration
	 tools.
8.	Discuss ways to                                                                           Familiarity         		None
	 influence performance
	 and results
	 in cross-cultural
	 teams.
9.	Examine the tradeoffs                                                                     Usage               		None
	 and common
	 sources of
	 risk in software
	 projects regarding
	 technology,
	 structure/process,
	 quality, people,
	 market and
	 financial.
10.	Evaluate personal                                                                         Assessment          		None
	 strengths and
	 weaknesses
	 to work remotely
	 as part of
	 a multinational
	 team.
Professional Ethics                                                                               2.0/2.0			0.0/0.0
1.	Identify ethical                                                                          Familiarity         		None
	 issues that
	 arise in software
	 development
	 and determine
	 how to address
	 them technically
	 and ethically.
2.	Explain the ethical                                                                       Familiarity         		None
	 responsibility
	 of ensuring
	 software correctness,
	 reliability
	 and safety.
	 
3.	Describe the mechanisms                                                                   Familiarity         		None
	 that typically
	 exist for a
	 professional
	 to keep up-to-date.
4.	Describe the strengths                                                                    Familiarity         		None
	 and weaknesses
	 of relevant
	 professional
	 codes as expressions
	 of professionalism
	 and guides
	 to decision-making.
5.	Analyze a global                                                                          Assessment          		None
	 computing issue,
	 observing the
	 role of professionals
	 and government
	 officials in
	 managing this
	 problem.
6.	Evaluate the professional                                                                 Assessment          		None
	 codes of ethics
	 from the ACM,
	 the IEEE Computer
	 Society, and
	 other organizations.
7.	Describe ways in                                                                          Familiarity         		None
	 which professionals
	 may contribute
	 to public policy.
8.	Describe the consequences                                                                 Familiarity         		None
	 of inappropriate
	 professional
	 behavior.
9.	Identify progressive                                                                      Familiarity         		None
	 stages in a
	 whistle-blowing
	 incident.
10.	Identify examples                                                                         Familiarity         		None
	 of how regional
	 culture interplays
	 with ethical
	 dilemmas.
11.	Investigate forms                                                                         Usage               		None
	 of harassment
	 and discrimination
	 and avenues
	 of assistance.
12.	Examine various                                                                           Usage               		None
	 forms of professional
	 credentialing.
13.	Explain the relationship                                                                  Familiarity         		None
	 between ergonomics
	 in computing
	 environments
	 and people’s
	 health.
14.	Develop a computer                                                                        Assessment          		None
	 usage/acceptable
	 use policy
	 with enforcement
	 measures.
15.	Describe issues                                                                           Familiarity         		None
	 associated
	 with industries’
	 push to focus
	 on time to
	 market versus
	 enforcing quality
	 professional
	 standards.
Security Policies, Laws and Computer Crimes                                                       0.0/0.0			0.0/0.0
1.	List classic examples                                                                     Familiarity         		None
	 of computer
	 crimes and
	 social engineering
	 incidents with
	 societal impact.
2.	Identify laws that                                                                        Familiarity         		None
	 apply to computer
	 crimes.
3.	Describe the motivation                                                                   Familiarity         		None
	 and  ramifications
	 of cyber terrorism
	 and criminal
	 hacking.
4.	Examine the ethical                                                                       Usage               		None
	 and legal issues
	 surrounding
	 the misuse
	 of access and
	 various breaches
	 in security.
5.	Discuss the professional's                                                                Familiarity         		None
	 role in security
	 and the trade-offs
	 involved.
6.	Investigate measures                                                                      Usage               		None
	 that can be
	 taken by both
	 individuals
	 and organizations
	 including governments
	 to prevent
	 or mitigate
	 the undesirable
	 effects of
	 computer crimes
	 and identity
	 theft.
7.	Write a company-wide                                                                      Usage               		None
	 security policy,
	 which includes
	 procedures
	 for managing
	 passwords and
	 employee monitoring.
Social Context                                                                                    1.0/2.0			0.0/0.0
1.	Describe positive                                                                         Familiarity         		None
	 and negative
	 ways in which
	 computer technology
	 (networks,
	 mobile computing,
	 cloud computing)
	 alters modes
	 of social interaction
	 at the personal
	 level.
2.	Identify developers’                                                                      Familiarity         		None
	 assumptions
	 and values
	 embedded in
	 hardware and
	 software design,
	 especially
	 as they pertain
	 to usability
	 for diverse
	 populations
	 including under-represented
	 populations
	 and the disabled.
3.	Interpret the social                                                                      Familiarity         		None
	 context of
	 a given design
	 and its implementation.
4.	Evaluate the efficacy                                                                     Assessment          		None
	 of a given
	 design and
	 implementation
	 using empirical
	 data.
5.	Summarize the implications                                                                Usage               		None
	 of social media
	 on individualism
	 versus collectivism
	 and culture.
6.	Discuss how Internet                                                                      Familiarity         		None
	 access serves
	 as a liberating
	 force for people
	 living under
	 oppressive
	 forms of government;
	 explain how
	 limits on Internet
	 access are
	 used as tools
	 of political
	 and social
	 repression.
7.	Analyze the pros                                                                          Assessment          		None
	 and cons of
	 reliance on
	 computing in
	 the implementation
	 of democracy
	 (eg delivery
	 of social services,
	 electronic
	 voting).
8.	Describe the impact                                                                       Familiarity         		None
	 of the under-representation
	 of diverse
	 populations
	 in the computing
	 profession
	 (eg, industry
	 culture, product
	 diversity).
9.	Explain the implications                                                                  Familiarity         		None
	 of context
	 awareness in
	 ubiquitous
	 computing systems.
Sustainability                                                                                    1.0/1.0			0.0/0.0
1.	Identify ways to                                                                          Familiarity         		None
	 be a sustainable
	 practitioner.
2.	Illustrate global                                                                         Usage               		None
	 social and
	 environmental
	 impacts of
	 computer use
	 and disposal
	 (e-waste).
3.	Describe the environmental                                                                Familiarity         		None
	 impacts of
	 design choices
	 within the
	 field of computing
	 that relate
	 to algorithm
	 design, operating
	 system design,
	 networking
	 design, database
	 design, etc.
4.	Investigate the                                                                           Usage               		None
	 social and
	 environmental
	 impacts of
	 new system
	 designs through
	 projects.
5.	Identify guidelines                                                                       Familiarity         		None
	 for sustainable
	 IT design or
	 deployment.
6.	List the sustainable                                                                      Familiarity         		None
	 effects of
	 telecommuting
	 or web shopping.
7.	Investigate pervasive                                                                     Usage               		None
	 computing in
	 areas such
	 as smart energy
	 systems, social
	 networking,
	 transportation,
	 agriculture,
	 supply-chain
	 systems, environmental
	 monitoring
	 and citizen
	 activism.
8.	Develop applications                                                                      Assessment          		None
	 of computing
	 and assess
	 through research
	 areas pertaining
	 to environmental
	 issues (eg
	 energy, pollution,
	 resource usage,
	 recycling and
	 reuse, food
	 management,
	 farming).

